module idtypes where

import univalence

refId (A : U) (a : A) : Id A a a =
  idC (<i> a) [  -> a ]

JJ (A : U) (a : A) (C : (x : A) -> Id A a x -> U) (d : C a (refId A a))
   (x : A) (p : Id A a x) : C x p
   = idJ A a C d x p

JJref (A : U) (a : A) (C : (x : A) -> Id A a x -> U) (d : C a (refId A a))
   : C a (refId A a)
   = idJ A a C d a (refId A a)

JJId (A : U) (a : A) (C : (x : A) -> Id A a x -> U) (d : C a (refId A a))
   : Id (C a (refId A a)) d (JJ A a C d a (refId A a))
   = refId (C a (refId A a)) d

substId (A : U) (F : A -> U) (a b : A) (p : Id A a b) (e : F a) : F b =
  JJ A a (\ (x : A) (_ : Id A a x) -> F x) e b p

substIdRef (A : U) (F : A -> U) (a : A) (e : F a) : F a =
  substId A F a a (refId A a) e

transId (A : U) (a b c : A) (p : Id A a b) (q : Id A b c) : Id A a c =
  substId A (\ (z : A) -> Id A a z) b c q p

transIdRef (A : U) (a b : A) (p : Id A a b): Id A a b =
  transId A a a b (refId A a) p

idToPath (A : U) (a b : A) (p : Id A a b) : Path A a b =
  idJ A a (\ (b : A) (p : Id A a b) -> Path A a b)
    (<i> a) b p

pathToId (A : U) (a b : A) (p : Path A a b) : Id A a b =
--  idC p []
  J A a (\ (b : A) (p : Path A a b) -> Id A a b)
    (refId A a) b p

pathToIdRef (A : U) (a : A) : Path (Id A a a) (refId A a) (pathToId A a a (<_> a)) =
  JEq A a (\ (b : A) (p : Path A a b) -> Id A a b) (refId A a)

idToPathRef (A : U) (a : A) : Path (Path A a a) (<_> a) (idToPath A a a (refId A a)) =
  <i j> a

pathToIdToPath (A : U) (a b : A) (p : Path A a b) :
  Path (Path A a b) p (idToPath A a b (pathToId A a b p)) =
  J A a (\ (b : A) (p : Path A a b) ->
    Path (Path A a b) p (idToPath A a b (pathToId A a b p)))
    (<j> idToPath A a a (pathToIdRef A a @ j)) b p

lem (A : U) (a : A) :
  Path (Id A a a) (refId A a) (pathToId A a a (idToPath A a a (refId A a))) =
    compPath (Id A a a)
      (refId A a) (pathToId A a a (<_> a)) (pathToId A a a (idToPath A a a (refId A a)))
      (pathToIdRef A a) (<k> pathToId A a a (idToPathRef A a @ k))

idToPathToId (A : U) (a b : A) (p : Id A a b) :
  Path (Id A a b) p (pathToId A a b (idToPath A a b p)) =
  idJ A a (\ (b : A) (p : Id A a b) ->
    Path (Id A a b) p (pathToId A a b (idToPath A a b p)))
    (lem A a) b p

PathIdPath (A B : U) : Path U (Id U A B) (Path U A B) =
  equivPath (Id U A B) (Path U A B) (idToPath U A B) rem
  where rem : isEquiv (Id U A B) (Path U A B) (idToPath U A B) =
          gradLemma (Id U A B) (Path U A B) (idToPath U A B) (pathToId U A B)
            (\(p : Path U A B) -> <i> pathToIdToPath U A B p @ - i)
            (\(p : Id U A B) -> <i> idToPathToId U A B p @ - i)

-- One version of univalence for Id
IdUnivalence1 (A B : U) : Path U (Id U A B) (equiv A B) = 
  compPath U (Id U A B) (Path U A B) (equiv A B) (PathIdPath A B) (corrUniv A B)

-- TODO: prove the following:

-- equivIdEquiv (A B : U) : equiv (Id U A B) (equiv A B) = undefined

-- IdUnivalence2 (A B : U) : Id U (Id U A B) (equiv A B) = undefined


--------------------------------------------------------------------------------
-- Some tests

mop (A B : U) (f : A -> B) (u v : A) (p : Id A u v) : Id B (f u) (f v) =
  JJ A u (\ (v : A) (p : Id A u v) -> Id B (f u) (f v))
    (refId B (f u)) v p

mopComp (A B C : U) (f : A -> B) (g : B -> C) (u v : A) (p : Id A u v)
  : Id C (g (f u)) (g (f v)) = mop A C (\ (x : A) -> g (f x)) u v p

mopComp' (A B C : U) (f : A -> B) (g : B -> C) (u v : A) (p : Id A u v)
  : Id C (g (f u)) (g (f v)) = mop B C g (f u) (f v) (mop A B f u v p)

superMop (A B : U) (f : A -> B) (u v : A) (p : Path A u v) : Id B (f u) (f v) =
  idC (<i> f (p @ i)) [ ]
