-- The integers as nat + nat with proof that suc is an iso giving a
-- non-trivial path from Z to Z
module int where

import equiv
import nat
import discor

       ---------------------------------------------------
       -- Example: Non-trivial equality between Z and Z --
       ---------------------------------------------------

Z : U = or nat nat

{- Z represents:

  +2 = inr (suc (suc zero))
  +1 = inr (suc zero)
   0 = inr zero
  -1 = inl zero
  -2 = inl (suc zero)

-}

zeroZ : Z = inr zero

sucZ : Z -> Z = split
  inl u -> auxsucZ u
    where
    auxsucZ : nat -> Z = split
      zero  -> inr zero
      suc n -> inl n
  inr v -> inr (suc v)

predZ : Z -> Z = split
  inl u -> inl (suc u)
  inr v -> auxpredZ v
    where
    auxpredZ : nat -> Z = split
      zero  -> inl zero
      suc n -> inr n

sucpredZ : (x : Z) -> Path Z (sucZ (predZ x)) x = split
  inl u -> refl Z (inl u)
  inr v -> lem v
   where
    lem : (u : nat) -> Path Z (sucZ (predZ (inr u))) (inr u) = split
      zero  -> refl Z (inr zero)
      suc n -> refl Z (inr (suc n))

predsucZ : (x : Z) -> Path Z (predZ (sucZ x)) x = split
  inl u -> lem u
   where
    lem : (u : nat) -> Path Z (predZ (sucZ (inl u))) (inl u) = split
      zero  -> refl Z (inl zero)
      suc n -> refl Z (inl (suc n))
  inr v -> refl Z (inr v)


sucPathZ : Path U Z Z = isoPath Z Z sucZ predZ sucpredZ predsucZ

-- We can transport along the proof forward and backwards:
testOneZ : Z = transport sucPathZ zeroZ
testNOneZ : Z = transport (<i> sucPathZ @ - i) zeroZ



ZSet : set Z = hedberg Z (orDisc nat nat natDec natDec)


-- Maybe we can generalize the notion of being a set to allow
-- arbitrary paths on the sides and not just refl?
gengoal (A : U) (hA : set A) (x y : A) (p : Path A x y) : (z : A) (r : Path A y z) (q : Path A x z) ->
  PathP (<i> Path A x (r @ i)) p q =
  J A y (\(z : A) (r : Path A y z) -> (q : Path A x z) -> PathP (<i> Path A x (r @ i)) p q)
   (hA x y p)

ctr (y : Z) : fiber Z Z sucZ y = (predZ y,<i> sucpredZ y @ -i)

contr (y : Z) (y' : fiber Z Z sucZ y) : Path ((x : Z) * Path Z y (sucZ x)) (ctr y) y' =
    let p1 : Path Z (predZ y) y'.1 =
          compPath Z (predZ y) (predZ (sucZ y'.1)) y'.1
                   (<i> predZ (y'.2 @ i)) (predsucZ y'.1)
        prf1 : Path Z (sucZ (predZ y)) (sucZ y'.1) = <i> sucZ (p1 @ i)
        prf2 : Path Z y (sucZ (predZ y)) = <i> sucpredZ y @ -i
        p2 : PathP (<i> Path Z y (prf1 @ i)) prf2 y'.2 =
          gengoal Z ZSet y (sucZ (predZ y)) prf2 (sucZ y'.1) prf1 y'.2
    in <i> (p1 @ i,p2 @ i)

-- This doesn't sem to affect "fibContrHopfThree' (<_ _ _> base2)"...
-- opaque contr

equivSucZ : isEquiv Z Z sucZ = \(y : Z) -> (ctr y,contr y)

sucPathZ' : Path U Z Z = ua Z Z (sucZ,equivSucZ)

