module compval where

Path (A : U) (a0 a1 : A) : U = PathP (<i> A) a0 a1

refl (A : U) (a : A) : Path A a a = <i> a

testEta (A : U) (a b : A) (p : Path A a b) : Path (Path A a b) p p = refl (Path A a b) (<i> p @ i)

mapOnPath (A B : U) (f : A -> B) (a b : A)
          (p : Path A a b) : Path B (f a) (f b) = <i> f (p @ i)

funExt (A : U) (B : A -> U) (f g : (x : A) -> B x)
       (p : (x : A) -> Path (B x) (f x) (g x)) :
       Path ((y : A) -> B y) f g = <i> \(a : A) -> (p a) @ i

inv (A : U) (a b : A) (p : Path A a b) : Path A b a =
  <i> comp (<_> A) a [(i=0) -> p,(i=1) -> <_> a]

-- Transport can be defined using comp
trans (A B : U) (p : Path U A B) (a : A) : B = comp p a []
transNeg (A B : U) (p : Path U A B) (b : B) : A = comp (inv U A B p) b []

-- subst can be defined using trans:
substTrans (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  trans (P a) (P b) (mapOnPath A U P a b p) e

subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transport (mapOnPath A U P a b p) e

substEq (A : U) (P : A -> U) (a : A) (e : P a)
  : Path (P a) e (subst A P a a (refl A a) e) =
  fill (<i> P a) e []

singl (A : U) (a : A) : U = (x : A) * Path A a x

contrSingl (A : U) (a b : A) (p : Path A a b) :
  Path (singl A a) (a,refl A a) (b,p) = <i> (p @ i,<j> p @ i/\j)

J (A : U) (a : A) (C : (x : A) -> Path A a x -> U)
  (d : C a (refl A a)) (x : A) (p : Path A a x) : C x p =
    subst (singl A a) T (a, refl A a) (x, p) (contrSingl A a x p) d
      where T (z : singl A a) : U = C (z.1) (z.2)

compPath (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c =
  <i> comp (<j>A) (p @ i) [ (i=0) -> <j> a, (i=1) -> q ]

transKinv (A : U) : (B : U) (p : Path U A B) (y : B) ->
                    Path B (trans A B p (transNeg A B p y)) y =
  J U A (\(B : U) (p : Path U A B) -> (y : B) -> Path B (trans A B p (transNeg A B p y)) y)
    rem
    where
    rem (x : A) : Path A (trans A A (<_> A) (transNeg A A (<_> A) x)) x =
        let
            goal2' : Path (Path U A A) (<_> A) (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) = <i j> fill (<_> U) A [ (j=0) -> <_> A, (j=1) -> <_> A ] @ i
            goal2 : Path (Path U A A) (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) (<_> A) = inv (Path U A A) (<_> A) (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) goal2'
            goal3 : Path A (comp (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) x [])
                           (comp (<i> A) x []) =
                           <i> comp (goal2 @ i) x []
            goal4 : Path A (comp (<i> A) x []) x = inv A x (comp (<i> A) x []) (fill (<i> A) x [])
            goal1 : Path A (comp (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) x []) x =
                       compPath A (comp (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) x [])
                                  (comp (<i> A) x []) x goal3 goal4
            goal1' : Path A x (comp (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) x []) = inv A (comp (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) x []) x goal1
            goal5 : Path A
                        x
                        (comp (<_> A)
                              (comp (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) x [])
                              [])
                         = <i> fill (<_> A) (goal1' @ i) [] @ i
            goal : Path A
                        (comp (<_> A)
                              (comp (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) x [])
                              [])
                        x = inv A x                         (comp (<_> A)
                              (comp (<i> comp (<_> U) A [ (i=0) -> <_> A, (i=1) -> <_> A ]) x [])
                              []) goal5

        in  goal


transNegKinv (A B : U) (p : Path U A B) (a : A) :
  Path A (transNeg A B p (trans A B p a)) a = undefined


-- transK (A B : U) (p : Path U A B) (y : B) :
--   Path B y (trans A B p (transNeg A B p y)) = undefined
--     <i> comp p (transNeg A B p y) [(i=0) -> rem1
--                                   ,(i=1) -> rem2 (transNeg A B p y)]
--     where
--     rem1 : PathP p (transNeg A B p y) y = undefined 
-- --      <i> comp (<j> p @ (i\/-j)) y [(i=1) -> <j>y]
--     rem2 (x:A) : PathP p x (trans A B p x) =
--       <i> comp (<j> p @ (i/\j)) x [(i=0) -> <j> x]

-- transNegK (A B : U) (p : Path U A B) (a : A) :
--   Path A a (transNeg A B p (trans A B p a)) = undefined
--     -- <i> comp (<j> p @ -j) (trans A B p a) [(i=0) -> rem1
--     --                                      ,(i=1) -> rem2 (trans A B p a) ]
--     -- where
--     -- rem1 : PathP (<i> p@-i) (trans A B p a) a = 
--     --    <i> comp (<j> p @ (-i /\ j)) a [(i=1) -> <j>a]
--     -- rem2 (b:B) : PathP (<i> p@-i) b (transNeg A B p b) = 
--     --   <i> comp (<j> p @ (-i \/ -j)) b [(i=0) -> <j> b]

-- Normal form of J:
-- comp (<i> C (p @ i) (<j> p @ i /\ j)) d []

-- Alternative proof of J
J' (A : U) (a : A) (C : (x : A) -> Path A a x -> U)
   (d : C a (<_> a)) (x : A) (p : Path A a x) : C x p =
   transport (<i> C (comp (<_> A) a [(i=0) -> <_> a,(i=1) -> p])
                    (fill (<_> A) a [(i=0) -> <_> a,(i=1) -> p])) d

-- Normal form of J':
-- comp (<i> C (comp (<_> A) a [ (i=0) -> <_> a, (i=1) -> p ])
--             (<j> comp (<_> A) a [ (i=0) -> <_> a, (i=1) -> <k> p @ j /\ k, (j=0) -> <_> a ])) d []

JEq (A : U) (a : A) (C : (x : A) -> Path A a x -> U) (d : C a (refl A a))
  : Path (C a (refl A a)) d (J A a C d a (refl A a)) =
  substEq (singl A a) T (a, refl A a) d
    where T (z : singl A a) : U = C (z.1) (z.2)


compPath' (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c =
  subst A (Path A a) b c q p

compPath'' (A : U) (a b : A) (p : Path A a b) : (c : A) -> (q : Path A b c) -> Path A a c =
  J A a ( \ (b : A) (p : Path A a b) -> (c : A) -> (q : Path A b c) -> Path A a c) rem b p
    where rem (c : A) (p : Path A a c) : Path A a c = p

compUp (A : U) (a a' b b' : A)
       (p : Path A a a') (q : Path A b b') (r : Path A a b) : Path A a' b' =
  <i> comp (<j>A) (r @ i) [(i = 0) -> p, (i = 1) -> q]

compDown (A : U) (a a' b b' : A)
         (p : Path A a a') (q: Path A b b') : Path A a' b' -> Path A a b =
 compUp A a' a b' b (inv A a a' p) (inv A b b' q)

test0 (A : U) (a b : A) (p : Path A a b) : Path A a a = refl A (p @ 0)
test1 (A : U) (a b : A) (p : Path A a b) : Path A b b = refl A (p @ 1)

-- compEmpty (A : U) (a b : A) (p : Path A a b) : Path A a b =
--   <i> comp A (p @ i) [ ]

kan (A : U) (a b c d : A) (p : Path A a b) (q : Path A a c)
                          (r : Path A b d) : Path A c d =
  <i> comp (<j>A) (p @ i) [ (i = 0) -> q, (i = 1) -> r ]

lemSimpl (A : U) (a b c : A) (p : Path A a b) (q q' : Path A b c)
  (s : Path (Path A a c) (compPath A a b c p q) (compPath A a b c p q')) :
  Path (Path A b c) q q' =
   <j k> comp (<i> A) a
           [ (j = 0) -> <i> comp (<l> A) (p @ i)
                              [ (k = 0) -> <l> p @ i
                              , (i = 0) -> <l> a
                              , (i = 1) -> <l> q @ k /\ l]
           , (j = 1) -> <i> comp (<l> A) (p @ i)
                              [ (k = 0) -> <l> p @ i
                              , (i = 0) -> <l> a
                              , (i = 1) -> <l> q' @ k /\ l]
           , (k = 0)  -> p
           , (k = 1)  -> s @ j ]

PathPathTest1 (A : U) (a b : A) (p : Path A a b) :
  Path (Path A a b) p (<i> comp (<j> A) (p @ i) [(i=0) -> <j> a,(i=1) -> <j> b]) =
  <j i> fill (<k> A) (p @ i) [(i=0) -> <k> a,(i=1) -> <k> b] @ j

idfun (A : U) (a : A) : A = a

--         u
--    a0 -----> a1
--    |         |
-- r0 |         | r1
--    |         |
--    V         V
--    b0 -----> b1
--         v
Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (PathP (<j> A) (u @ i) (v @ i))) r0 r1

prop (A : U) : U = (a b : A) -> Path A a b
set (A : U) : U = (a b : A) -> prop (Path A a b)
groupoid (A : U) : U = (a b : A) -> set (Path A a b)

-- the collection of all sets
SET : U = (X:U) * set X

propSet (A : U) (h : prop A) : set A =
 \(a b : A) (p q : Path A a b) ->
   <j i> comp (<k>A) a [ (i=0) -> h a a
                       , (i=1) -> h a b
                       , (j=0) -> h a (p @ i)
                       , (j=1) -> h a (q @ i)]

propIsProp (A : U) : prop (prop A) =
  \(f g : prop A) -> <i> \(a b : A) ->
    propSet A f a b (f a b) (g a b) @ i

setIsProp (A : U) : prop (set A) =
 \(f g : set A) -> <i> \(a b :A) ->
   propIsProp (Path A a b) (f a b) (g a b) @ i

PathS (A : U) (P : A -> U) (a0 a1 : A)
  (p : Path A a0 a1) (u0 : P a0) (u1 : P a1) : U =
    PathP (<i> P (p @ i)) u0 u1

lemProp (A : U) (h : A -> prop A) : prop A =
  \(a : A) -> h a a

propPi (A : U) (B : A -> U) (h : (x : A) -> prop (B x))
       (f0 f1 : (x : A) -> B x) : Path ((x : A) -> B x) f0 f1
  = <i> \ (x:A) -> (h x (f0 x) (f1 x)) @ i

-- other proof
lemPropF (A : U) (P : A -> U) (pP : (x : A) -> prop (P x)) (a :A) :
         (a1 : A) (p : Path A a a1) (b0 : P a) (b1 : P a1) -> PathP (<i>P (p@i)) b0 b1 =
 J A a (\ (a1 : A) (p : Path A a a1) ->
         (b0 : P a) (b1 : P a1) -> PathP (<i>P (p@i)) b0 b1)
  rem
 where rem : (b0 b1:P a) -> Path (P a) b0 b1 = pP a

Sigma (A : U) (B : A -> U) : U = (x : A) * B x

lemSig (A : U) (B : A -> U) (pB : (x : A) -> prop (B x))
       (u v : (x:A) * B x) (p : Path A u.1 v.1) :
       Path ((x:A) * B x) u v =
  <i> (p@i,(lemPropF A B pB u.1 v.1 p u.2 v.2)@i)

propSig (A : U) (B : A -> U) (pA : prop A)
        (pB : (x : A) -> prop (B x)) (t u : (x:A) * B x) :
        Path ((x:A) * B x) t u =
  lemSig A B pB t u (pA t.1 u.1)

isContr (A : U) : U = (x : A) * ((y : A) -> Path A x y)

propIsContr (A : U) : prop (isContr A) = lemProp (isContr A) rem
  where
    rem (t : isContr A) : prop (isContr A) = propSig A T pA pB
      where
        T (x : A) : U = (y : A) -> Path A x y
        pA (x y : A) : Path A x y = compPath A x t.1 y (inv A t.1 x (t.2 x)) (t.2 y)
        pB (x : A) : prop (T x) =
          propPi A (\ (y : A) -> Path A x y) (propSet A pA x)

isContrProp (A : U) (h : isContr A) : prop A =
  \(a b : A) -> <i> comp (<_> A) h.1 [ (i = 0) -> h.2 a, (i = 1) -> h.2 b ]


-- Alternative proof:
-- propIsContr (A:U) (z0 z1:isContr A) : Path (isContr A) z0 z1 =
--  <j>(p0 a1@j,
--      \ (x:A) ->
--         <i>comp (<_>A) (lem1 x@i@j) [ (i=0) -> <k>p0 a1@j, (i=1) -> <k>p0 x@(j\/k),
--                                       (j=0) -> <k>p0 x@(i/\k), (j=1) -> <k>p1 x@i ])
--  where
--   a0 : A = z0.1
--   p0 : (x:A) -> Path A a0 x = z0.2
--   a1 : A = z1.1
--   p1 : (x:A) -> Path A a1 x = z1.2
--   lem1 (x:A) : PathP (<i>Path A a0 (p1 x@i)) (p0 a1) (p0 x) = <i j> p0 (p1 x@i) @ j


-- Basic data types

data N0 =

efq (A : U) : N0 -> A = split {}
neg (A : U) : U = A -> N0

data Unit = tt

propUnit : prop Unit = split
 tt -> split@((x:Unit) -> Path Unit tt x) with
  tt -> <i> tt

setUnit : set Unit = propSet Unit propUnit

data or (A B : U) = inl (a : A)
                  | inr (b : B)

propOr (A B : U) (hA : prop A) (hB : prop B) (h : A -> neg B) : prop (or A B) = split
    inl a' -> split@((b : or A B) -> Path (or A B) (inl a') b) with
        inl b' -> <i> inl (hA a' b' @ i)
        inr b' -> efq (Path (or A B) (inl a') (inr b')) (h a' b')
    inr a' -> split@((b : or A B) -> Path (or A B) (inr a') b) with
        inl b' -> efq (Path (or A B) (inr a') (inl b')) (h b' a')
        inr b' -> <i> inr (hB a' b' @ i)

-- Direct proof that or A B is a set if A and B are:
invOr (A B : U) : (u v : or A B) (p : Path (or A B) u v) -> U = split
  inl a -> split@((v : or A B) -> (p : Path (or A B) (inl a) v) -> U) with
    inl a' -> \(p : Path (or A B) (inl a) (inl a')) ->
              (q : Path A a a') * (Path (Path (or A B) (inl a) (inl a')) p (<i> inl (q @ i)))
    inr b' -> \(p : Path (or A B) (inl a) (inr b')) -> N0
  inr b -> split@((v : or A B) -> (p : Path (or A B) (inr b) v) -> U) with
    inl a' -> \(p : Path (or A B) (inr b) (inl a')) -> N0
    inr b' -> \(p : Path (or A B) (inr b) (inr b')) ->
              (q : Path B b b') * (Path (Path (or A B) (inr b) (inr b')) p (<i> inr (q @ i)))

pinvOr (A B : U) : (u v : or A B) (p : Path (or A B) u v) -> invOr A B u v p = split
  inl a -> J (or A B) (inl a) (invOr A B (inl a)) (<_> a,<_ _> inl a)
  inr b -> J (or A B) (inr b) (invOr A B (inr b)) (<_> b,<_ _> inr b)

lemOr (A B : U) (setA : set A) (setB : set B) :
  (u : or A B) (p : Path (or A B) u u) -> Path (Path (or A B) u u) p (<_> u) = split
  inl a -> \(p : Path (or A B) (inl a) (inl a)) -> 
    let qa : invOr A B (inl a) (inl a) p = pinvOr A B (inl a) (inl a) p
    in compPath (Path (or A B) (inl a) (inl a)) p (<i> inl (qa.1 @ i)) (<_> inl a) qa.2
                (<i j> inl (setA a a qa.1 (<_> a) @ i @ j))
  inr b -> \(p : Path (or A B) (inr b) (inr b)) -> 
    let qb : invOr A B (inr b) (inr b) p = pinvOr A B (inr b) (inr b) p
    in compPath (Path (or A B) (inr b) (inr b)) p (<i> inr (qb.1 @ i)) (<_> inr b) qb.2
                (<i j> inr (setB b b qb.1 (<_> b) @ i @ j))

orset' (A B : U) (setA : set A) (setB : set B) (u : or A B) :
  (v : or A B) (p q : Path (or A B) u v) -> Path (Path (or A B) u v) q p =
  J (or A B) u (\(v : or A B) (p : Path (or A B) u v) ->
               (q : Path (or A B) u v) -> Path (Path (or A B) u v) q p)
    (lemOr A B setA setB u)

orset (A B : U) (setA : set A) (setB : set B) (u v : or A B) (p q : Path (or A B) u v) :
  Path (Path (or A B) u v) p q = orset' A B setA setB u v q p


stable (A:U) : U = neg (neg A) -> A

const (A : U) (f : A -> A) : U = (x y : A) -> Path A (f x) (f y)

exConst (A : U) : U = (f:A -> A) * const A f

propN0 : prop N0 = \ (x y:N0) -> efq (Path N0 x y) x

propNeg (A:U) : prop (neg A) = \ (f g:neg A) -> <i>\(x:A) -> (propN0 (f x) (g x))@i

dNeg (A:U) (a:A) : neg (neg A) = \ (h : neg A) -> h a

dec (A : U) : U = or A (neg A)

propDec (A : U) (h : prop A) : prop (dec A) =
  propOr A (neg A) h (propNeg A) (\(x : A) (h : neg A) -> h x)

decEqCong (A B : U) (f : A -> B) (g : B -> A) : dec A -> dec B = split
  inl a -> inl (f a)
  inr h -> inr (\ (b:B) -> h (g b))

decStable (A:U) : dec A -> stable A = split
 inl a -> \ (h :neg (neg A)) -> a
 inr b -> \ (h :neg (neg A)) -> efq A (h b)

decConst (A : U) : dec A -> exConst A = split
  inl a -> (\ (x:A)  -> a, \ (x y:A) -> refl A a)
  inr h -> (\ (x:A) -> x, \ (x y:A) -> efq (Path A x y) (h x))

stableConst (A : U) (sA: stable A) : exConst A =
 (\ (x:A) -> sA (dNeg A x),\ (x y:A) -> <i>sA (propNeg (neg A) (dNeg A x) (dNeg A y) @ i))

discrete (A : U) : U = (a b : A) -> dec (Path A a b)

injective (A B : U) (f : A -> B) : U =
  (a0 a1 : A) -> Path B (f a0) (f a1) -> Path A a0 a1

and (A B : U) : U = (_ : A) * B

propAnd (A B : U) (pA : prop A) (pB : prop B) : prop (and A B) =
  propSig A (\(_ : A) -> B) pA (\(_ : A) -> pB)

fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)

isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)

equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

propIsEquiv (A B : U) (f : A -> B)
  : prop (isEquiv A B f) =
  \ (u0 u1:isEquiv A B f) ->
    <i> \ (y:B) -> propIsContr (fiber A B f y) (u0 y) (u1 y) @ i

idIsEquiv (A : U) : isEquiv A A (idfun A) =
  \(a : A) -> ((a, refl A a)
              ,\(z : fiber A A (idfun A) a) -> contrSingl A a z.1 z.2)

equivPath (T A : U) (f : T -> A) (p : isEquiv T A f) : Path U T A =
  <i> Glue A [ (i=0) -> (T,f,p), (i=1) -> (A,idfun A, idIsEquiv A)]

-- for univalence
invEq (A B:U) (w:equiv A B) (y:B) : A = (w.2 y).1.1

retEq (A B:U) (w:equiv A B) (y:B) : Path B (w.1 (invEq A B w y)) y =
  inv B y (w.1 (invEq A B w y)) (w.2 y).1.2

secEq (A B:U) (w:equiv A B) (x:A) : Path A (invEq A B w (w.1 x)) x =
 <i> ((w.2 (w.1 x)).2 (x,<j>w.1 x)@i).1
 --

lemSinglContr (A:U) (a:A) : isContr ((x:A) * Path A a x) =
 ((a,refl A a),\ (z:(x:A) * Path A a x) -> contrSingl A a z.1 z.2)

idEquiv (A:U) : equiv A A = (\ (x:A) -> x, lemSinglContr A)

transEquiv (A B : U) (p : Path U A B) : equiv A B =
 subst U (equiv A) A B p (idEquiv A)

transDelta (A:U) : equiv A A = transEquiv A A (<i>A)

transEquivToPath (A B : U) (w : equiv A B) : Path U A B =
  <i> Glue B [ (i = 1) -> (B,eB)
             , (i = 0) -> (A,w) ]
 where eB : equiv B B = transDelta B

eqToEq (A B : U) (p : Path U A B)
  : Path (Path U A B) (transEquivToPath A B (transEquiv A B p)) p
  = <j i> let e : equiv A B = transEquiv A B p
              f : equiv B B = transDelta B
              Ai : U = p@i
              g : equiv Ai B = transEquiv Ai B (<k> p @ (i \/ k))
          in Glue B
           [ (i = 0) -> (A,e)
           , (i = 1) -> (B,f)
           , (j = 1) -> (p@i,g)]

-- The iso to equiv

lemIso (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x)
       (y : B) (x0 x1 : A) (p0 : Path B y (f x0)) (p1 : Path B y (f x1)) :
       Path (fiber A B f y) (x0,p0) (x1,p1) = <i> (p @ i,sq1 @ i)
  where
    rem0 : Path A (g y) x0 =
      <i> comp (<k> A) (g (p0 @ i)) [ (i = 1) -> t x0, (i = 0) -> <k> g y ]

    rem0fill : Square A (g y) (g (f x0)) (g y) x0
                        (<i> g (p0 @ i)) rem0 (<i> g y) (t x0)  =
      <i> fill (<k> A) (g (p0 @ i)) [ (i = 1) -> t x0, (i = 0) -> <k> g y ]

    rem1 : Path A (g y) x1 =
      <i> comp (<k> A) (g (p1 @ i)) [ (i = 1) -> t x1, (i = 0) -> <k> g y ]

    rem1fill : Square A (g y) (g (f x1)) (g y) x1
                        (<i> g (p1 @ i)) rem1 (<i> g y) (t x1) =
      <i> fill (<k> A) (g (p1 @ i)) [ (i = 1) -> t x1, (i = 0) -> <k> g y ]

    p : Path A x0 x1 =
      <i> comp (<k> A) (g y) [ (i = 1) -> rem1, (i = 0) -> rem0 ]

    pfill : Square A (g y) (g y) x0 x1
                     (<k> g y) p rem0 rem1 =
      <i> fill (<k> A) (g y) [ (i = 1) -> rem1, (i = 0) -> rem0 ]

    sq : Square A (g y) (g y) (g (f x0)) (g (f x1))
                  (<i> g y) (<i> g (f (p @ i)))
                  (<j> g (p0 @ j)) (<j> g (p1 @ j)) = undefined 
      -- <i j> comp (<k> A) (pfill @ i @ j) [ (i = 0) -> <k> rem0fill @ j @ -k ]
      --                                    , (i = 1) -> <k> rem1fill @ j @ -k
      --                                    , (j = 0) -> <k> g y
      --                                    , (j = 1) -> <k> t (p @ i) @ -k ]

    sq1 : Square B y y (f x0) (f x1)
                   (<k>y) (<i> f (p @ i)) p0 p1 =
      <i j> comp (<k> B) (f (sq @ i @j)) [ (i = 0) -> s (p0 @ j)
                                         , (i = 1) -> s (p1 @ j)
                                         , (j = 1) -> s (f (p @ i))
                                         , (j = 0) -> s y ]

isoToEquiv (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x) : isEquiv A B f =
  \(y:B) -> ((g y,inv B (f (g y)) y (s y)),\ (z:fiber A B f y) ->
    lemIso A B f g s t y (g y) z.1 (inv B (f (g y)) y (s y)) z.2)

isoPath (A B : U) (f : A -> B) (g : B -> A)
      (s : (y : B) -> Path B (f (g y)) y)
      (t : (x : A) -> Path A (g (f x)) x) : Path U A B =
       <i> Glue B [ (i = 0) -> (A,f,isoToEquiv A B f g s t)
                  , (i = 1) -> (B,idfun B,idIsEquiv B) ]

idIsEquivIsoToEquiv (A : U) : isEquiv A A (idfun A) =
  isoToEquiv A A (idfun A) (idfun A) (\(a : A) -> <i> a) (\(a : A) -> <i> a)


univalenceAlt (B : U) : isContr ((X : U) * equiv X B) =
 ((B,idEquiv B)
 ,\(w : (X : U) * equiv X B) ->
   <i> let GlueB : U = Glue B [(i=0) -> (B,idEquiv B)
                              ,(i=1) -> w]
           unglueB (g : GlueB) : B = unglue g [(i=0) -> (B,idEquiv B)
                                              ,(i=1) -> w]
           unglueEquiv : isEquiv GlueB B unglueB =
              \(b : B)-> let ctr : fiber GlueB B unglueB b =
                               (glue (comp (<j> B) b [(i=0) -> <j> b
                                                     ,(i=1) -> (w.2.2 b).1.2])
                                     [(i=0) -> b
                                     ,(i=1) -> (w.2.2 b).1.1]
                               ,fill (<j> B) b [(i=0) -> <j> b
                                               ,(i=1) -> (w.2.2 b).1.2])
                             contr (v : fiber GlueB B unglueB b) : Path (fiber GlueB B unglueB b) ctr v =
                               <j> (glue (comp (<j> B) b [(i=0) -> <k> v.2 @ j /\ k
                                                         ,(i=1) -> ((w.2.2 b).2 v @ j).2
                                                         ,(j=0) -> fill (<j> B) b [(i=0) -> <j> b
                                                                                  ,(i=1) -> (w.2.2 b).1.2]
                                                         ,(j=1) -> v.2])
                                         [(i=0) -> v.2 @ j
                                         ,(i=1) -> ((w.2.2 b).2 v @ j).1]
                                   ,fill (<j> B) b [(i=0) -> <l> v.2 @ j /\ l
                                                   ,(i=1) -> ((w.2.2 b).2 v @ j).2
                                                   ,(j=0) -> fill (<j> B) b [(i=0) -> <j> b
                                                                            ,(i=1) -> (w.2.2 b).1.2]
                                                   ,(j=1) -> v.2])
                         in (ctr,contr)
        in (GlueB,unglueB,unglueEquiv))


contrSingl' (A : U) (a b : A) (p : Path A a b) :
  Path ((x:A) * Path A x b) (b,<_> b) (a,p) = undefined -- <i> (p @ -i,<j> p @ -i\/j)

lemSinglContr' (A:U) (a:A) : isContr ((x:A) * Path A x a) =
 ((a,refl A a),\ (z:(x:A) * Path A x a) -> contrSingl' A z.1 a z.2)

retIsContr (A B : U) (f : A -> B) (g : B -> A)
           (h : (x : A) -> Path A (g (f x)) x) (v : isContr B)
           : isContr A = (g b,p)
 where
  b : B = v.1
  q : (y:B) -> Path B b y = v.2
  p (x:A) : Path A (g b) x =
    <i> comp (<_> A) (g (q (f x) @ i)) [(i=0) -> <j>g b,(i=1) -> h x]

sigIsContr (A : U) (B : A -> U) (u : isContr A)
  (q : (x : A) -> isContr (B x)) : isContr ((x:A) * B x) = ((a,g a),r)
 where
  a : A = u.1
  p : (x:A) -> Path A a x = u.2
  g (x:A) : B x = (q x).1
  h (x:A) : (y:B x) -> Path (B x) (g x) y = (q x).2
  C : U = (x:A) * B x
  r (z:C) : Path C (a,g a) z = undefined
--   <i>(p z.1@i,h (p z.1@i) (comp (<j>B (p z.1@i\/-j)) z.2 [(i=1)-><j>z.2])@i)

isPathContr (A:U) (cA:isContr A) (x y:A) : isContr (Path A x y) =  (p0,q)
 where
  a : A = cA.1
  f : (x:A) -> Path A a x = cA.2
  p0 : Path A x y = <i>comp (<j>A) a [(i=0) -> f x,(i=1) -> f y]
  q (p:Path A x y) : Path (Path A x y) p0 p =
   <j i>comp (<k>A) a [(i=0) -> f x,(i=1) -> f y,
                       (j=0) -> <k>comp (<l>A) a [(k=0) -> <l>a,(i=0) -> <l>f x@k/\l,(i=1) -> <l>f y@k/\l],
                       (j=1) -> f (p@i)]

isEquivContr (A B:U) (cA:isContr A) (cB:isContr B) (f:A->B) : isEquiv A B f =
 \ (y:B) -> sigIsContr A (\ (x:A) -> Path B y (f x)) cA (\ (x:A) -> isPathContr B cB y (f x))

totalFun (A:U) (B C : A->U) (f : (x:A) -> B x -> C x) (w:Sigma A B) : Sigma A C =
 (w.1,f (w.1) (w.2))

funFib1  (A:U) (B C : A->U) (f : (x:A) -> B x -> C x) (x0:A) (z0:C x0) (u:fiber (B x0) (C x0) (f x0) z0) :
 fiber (Sigma A B) (Sigma A C) (totalFun A B C f) (x0,z0) =  ((x0,u.1),<i>(x0,u.2@i))

funFib2  (A:U) (B C : A->U) (f : (x:A) -> B x -> C x) (x0:A) (z0:C x0)
         (w : fiber (Sigma A B) (Sigma A C) (totalFun A B C f) (x0,z0)) : fiber (B x0) (C x0) (f x0) z0 = undefined -- (b0,s)
 -- where
 --  x : A = w.1.1
 --  b : B x = w.1.2
 --  p : Path A x0 x = <i>(w.2@i).1
 --  q : PathP (<i>C (p@i)) z0 (f x b) = <i>(w.2@i).2
 --  b0 : B x0 = comp (<i>B (p@-i)) b []
 --  r : PathP (<i>B (p@-i)) b b0 = <i>comp (<j>B (p@-j\/-i)) b [(i=0) -> <k>b]
 --  s : Path (C x0) z0 (f x0 b0) = <i>comp (<j>C (p@(i/\-j))) (q@i) [(i=0) -> <k>z0,(i=1) -> <k>f (p@-k) (r@k)]

compFunFib (A:U) (B C : A->U) (f : (x:A) -> B x -> C x) (x0:A) (z0:C x0) (u:fiber (B x0) (C x0) (f x0) z0) :
    fiber (B x0) (C x0) (f x0) z0 = funFib2 A B C f x0 z0 (funFib1 A B C f x0 z0 u)

retFunFib (A:U) (B C : A->U) (f : (x:A) -> B x -> C x) (x0:A) (z0:C x0) (u:fiber (B x0) (C x0) (f x0) z0) :
   Path (fiber (B x0) (C x0) (f x0) z0) (funFib2 A B C f x0 z0 (funFib1 A B C f x0 z0 u)) u = undefined
 -- <l> (comp (<i> B x0) u.1 [(l=1) -> <j>u.1],
 --      <i> comp (<j> C x0) (u.2 @ i) [ (l=1) -> <j> u.2 @ i,
 --                                      (i = 0) -> <j> z0,
 --                                      (i = 1) -> <j> f x0 (comp (<k> B x0) u.1 [ (j = 0) -> <k> u.1, (l=1) -> <k>u.1 ]) ])

equivFunFib (A:U) (B C : A->U) (f : (x:A) -> B x -> C x) (cB : isContr (Sigma A B)) (cC : isContr (Sigma A C)) (x:A)
  : isEquiv (B x) (C x) (f x) =
 \ (z:C x) -> retIsContr (fiber (B x) (C x) (f x) z) (fiber (Sigma A B) (Sigma A C) (totalFun A B C f) (x,z))
                         (funFib1 A B C f x z)
                         (funFib2 A B C f x z)
                         (retFunFib A B C f x z)
                         (isEquivContr (Sigma A B) (Sigma A C) cB cC (totalFun A B C f) (x,z))

-- A version univalence. This is Corollary 11 of the cubical type
-- theory paper.
thmUniv (t : (A X : U) -> Path U X A -> equiv X A) (A : U) :
  (X : U) -> isEquiv (Path U X A) (equiv X A) (t A X) =
    equivFunFib U (\(X : U) -> Path U X A) (\(X : U) -> equiv X A)
      (t A) (lemSinglContr' U A) (univalenceAlt A)

transEquiv' (A X : U) (p : Path U X A) : equiv X A =
  substTrans U (\(Y : U) -> equiv Y A) A X (inv U X A p) (idEquiv A)

-- The univalence axiom
univalence (A X : U) : isEquiv (Path U X A) (equiv X A) (transEquiv' A X) =
  thmUniv transEquiv' A X

-- The standard formulation of univalence whose normal can be computed:
corrUniv (A B : U) : Path U (Path U A B) (equiv A B) =
 equivPath (Path U A B) (equiv A B) (transEquiv' B A) (univalence B A)

corrUniv' (A B : U) : equiv (Path U A B) (equiv A B) =
  (transEquiv' B A,univalence B A)

-- Univalence using Id:


refId (A : U) (a : A) : Id A a a =
  idC (<i> a) [  -> a ]

JJ (A : U) (a : A) (C : (x : A) -> Id A a x -> U) (d : C a (refId A a))
   (x : A) (p : Id A a x) : C x p
   = idJ A a C d x p

JJref (A : U) (a : A) (C : (x : A) -> Id A a x -> U) (d : C a (refId A a))
   : C a (refId A a)
   = idJ A a C d a (refId A a)

JJId (A : U) (a : A) (C : (x : A) -> Id A a x -> U) (d : C a (refId A a))
   : Id (C a (refId A a)) d (JJ A a C d a (refId A a))
   = refId (C a (refId A a)) d

substId (A : U) (F : A -> U) (a b : A) (p : Id A a b) (e : F a) : F b =
  JJ A a (\ (x : A) (_ : Id A a x) -> F x) e b p

substIdRef (A : U) (F : A -> U) (a : A) (e : F a) : F a =
  substId A F a a (refId A a) e

transId (A B : U) (p : Id U A B) (a : A) : B =
  substId U (idfun U) A B p a

transIdRef (A B : U) (p : Id U A B) (a : A) :
  Id A (transId A A (refId U A) a) a = refId A a

compId (A : U) (a b c : A) (p : Id A a b) (q : Id A b c) : Id A a c =
  substId A (\ (z : A) -> Id A a z) b c q p

compIdRef (A : U) (a b : A) (p : Id A a b): Id A a b =
  compId A a a b (refId A a) p

idToPath (A : U) (a b : A) (p : Id A a b) : Path A a b =
  idJ A a (\ (b : A) (p : Id A a b) -> Path A a b)
    (<i> a) b p

pathToId (A : U) (a b : A) (p : Path A a b) : Id A a b =
--  idC p []
  J A a (\ (b : A) (p : Path A a b) -> Id A a b)
    (refId A a) b p

pathToIdRef (A : U) (a : A) : Path (Id A a a) (refId A a) (pathToId A a a (<_> a)) =
  JEq A a (\ (b : A) (p : Path A a b) -> Id A a b) (refId A a)

idToPathRef (A : U) (a : A) : Path (Path A a a) (<_> a) (idToPath A a a (refId A a)) =
  <i j> a

pathToIdToPath (A : U) (a b : A) (p : Path A a b) :
  Path (Path A a b) p (idToPath A a b (pathToId A a b p)) =
  J A a (\ (b : A) (p : Path A a b) ->
    Path (Path A a b) p (idToPath A a b (pathToId A a b p)))
    (<j> idToPath A a a (pathToIdRef A a @ j)) b p

lem (A : U) (a : A) :
  Path (Id A a a) (refId A a) (pathToId A a a (idToPath A a a (refId A a))) =
    compPath (Id A a a)
      (refId A a) (pathToId A a a (<_> a)) (pathToId A a a (idToPath A a a (refId A a)))
      (pathToIdRef A a) (<k> pathToId A a a (idToPathRef A a @ k))

idToPathToId (A : U) (a b : A) (p : Id A a b) :
  Path (Id A a b) p (pathToId A a b (idToPath A a b p)) =
  idJ A a (\ (b : A) (p : Id A a b) ->
    Path (Id A a b) p (pathToId A a b (idToPath A a b p)))
    (lem A a) b p

PathIdPath (A B : U) : Path U (Id U A B) (Path U A B) =
  equivPath (Id U A B) (Path U A B) (idToPath U A B) rem
  where rem : isEquiv (Id U A B) (Path U A B) (idToPath U A B) =
          isoToEquiv (Id U A B) (Path U A B) (idToPath U A B) (pathToId U A B)
            (\(p : Path U A B) -> inv (Path U A B) p (idToPath U A B (pathToId U A B p)) (pathToIdToPath U A B p))
            (\(p : Id U A B) -> inv (Id U A B) p (pathToId U A B (idToPath U A B p)) (idToPathToId U A B p))

-- A few different versions of univalence for Id:
IdUnivalence1 (A B : U) : Path U (Id U A B) (equiv A B) =
  compPath U (Id U A B) (Path U A B) (equiv A B) (PathIdPath A B) (corrUniv A B)

IdUnivalence2 (A B : U) : equiv (Id U A B) (equiv A B) =
  transEquiv' (equiv A B) (Id U A B) (IdUnivalence1 A B)

IdUnivalence3 (A B : U) : Id U (Id U A B) (equiv A B) =
  pathToId U (Id U A B) (equiv A B) (IdUnivalence1 A B)


-- Redefine equivalence using Id and prove univalence with this formulation

fiberId (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Id B y (f x)

isContrId (A : U) : U = (x : A) * ((y : A) -> Id A x y)

isEquivId (A B : U) (f : A -> B) : U = (y : B) -> isContrId (fiberId A B f y)

equivId (A B : U) : U = (f : A -> B) * isEquivId A B f

invEquivId (A B : U) (w : equivId A B) (b : B) : A = (w.2 b).1.1

fiberToFiberId (A B : U) (f : A -> B) (y : B) :
  Path U (fiber A B f y) (fiberId A B f y) =
    isoPath (fiber A B f y) (fiberId A B f y) f1 f2 rem1 rem2
  where
  f1 (t : fiber A B f y) : fiberId A B f y = (t.1,pathToId B y (f t.1) t.2)
  f2 (t : fiberId A B f y) : fiber A B f y = (t.1,idToPath B y (f t.1) t.2)
  rem1 (x : fiberId A B f y) : Path (fiberId A B f y) (f1 (f2 x)) x =
    <i> (x.1,inv (Id B y (f x.1)) x.2 (pathToId B y (f x.1) (idToPath B y (f x.1) x.2)) (idToPathToId B y (f x.1) x.2) @ i)
  rem2 (x : fiber A B f y) : Path (fiber A B f y) (f2 (f1 x)) x =
    <i> (x.1,inv (Path B y (f x.1)) x.2 (idToPath B y (f x.1) (pathToId B y (f x.1) x.2)) (pathToIdToPath B y (f x.1) x.2) @ i)

isContrToIsContrId (A : U) (p : isContr A) : isContrId A =
  (p.1,\(y : A) -> pathToId A p.1 y (p.2 y))

equivToEquivId (A B : U) (e : equiv A B) : equivId A B = (f,rem)
  where
  f : A -> B = e.1
  rem (y : B) : isContrId (fiberId A B f y) =
    transport (<i> isContrId (fiberToFiberId A B f y @ i))
              (isContrToIsContrId (fiber A B f y) (e.2 y))

-- idToPathToId (A : U) (a b : A) (p : Id A a b) :
--   Path (Id A a b) p (pathToId A a b (idToPath A a b p)) =

isContrToIsContrIdU (A : U) : Path U (isContr A) (isContrId A) =
   isoPath (isContr A) (isContrId A) f1 f2 rem1 rem2
  where
  f1 : isContr A -> isContrId A = isContrToIsContrId A
  f2 (p : isContrId A) : isContr A = (p.1,\(y : A) -> idToPath A p.1 y (p.2 y))

  rem1 (x : isContrId A) : Path (isContrId A) (f1 (f2 x)) x =
   <i> (x.1,\(y : A) -> inv (Id A x.1 y) (x.2 y) (pathToId A x.1 y (idToPath A x.1 y (x.2 y))) (idToPathToId A x.1 y (x.2 y)) @ i)
  rem2 (x : isContr A) : Path (isContr A) (f2 (f1 x)) x =
    <i> (x.1,\(y : A) -> inv (Path A x.1 y) (x.2 y) (idToPath A x.1 y (pathToId A x.1 y (x.2 y))) (pathToIdToPath A x.1 y (x.2 y)) @ i)

isContrFiberToIsContrFiberId (A B : U) (f : A -> B) (y : B) :
  Path U (isContr (fiber A B f y)) (isContrId (fiberId A B f y)) = goal
  where
  rem1 : Path U (isContr (fiber A B f y)) (isContr (fiberId A B f y)) =
    <i> isContr (fiberToFiberId A B f y @ i)
  rem2 : Path U (isContr (fiberId A B f y)) (isContrId (fiberId A B f y)) =
    isContrToIsContrIdU (fiberId A B f y)
  goal : Path U (isContr (fiber A B f y)) (isContrId (fiberId A B f y)) =
    compPath U (isContr (fiber A B f y)) (isContr (fiberId A B f y))
               (isContrId (fiberId A B f y)) rem1 rem2


equivEquivIdU (A B : U) : Path U (equiv A B) (equivId A B) =
  isoPath (equiv A B) (equivId A B) f1 f2 rem1 rem2
  where
  f1 (p : equiv A B) : equivId A B =
    (p.1,\(y : B) -> trans (isContr (fiber A B p.1 y))
                           (isContrId (fiberId A B p.1 y))
                           (isContrFiberToIsContrFiberId A B p.1 y) (p.2 y))
  f2 (p : equivId A B) : equiv A B =
    (p.1,\(y : B) -> transNeg (isContr (fiber A B p.1 y))
                              (isContrId (fiberId A B p.1 y))
                              (isContrFiberToIsContrFiberId A B p.1 y) (p.2 y))

  rem1 (x : equivId A B) : Path (equivId A B) (f1 (f2 x)) x =
    <i> (x.1,\(y : B) -> transKinv (isContr (fiber A B x.1 y))
                                (isContrId (fiberId A B x.1 y))
                                (isContrFiberToIsContrFiberId A B x.1 y) (x.2 y) @ i)

  rem2 (x : equiv A B) : Path (equiv A B) (f2 (f1 x)) x =
    <i> (x.1,\(y : B) -> transNegKinv (isContr (fiber A B x.1 y))
                                   (isContrId (fiberId A B x.1 y))
                                   (isContrFiberToIsContrFiberId A B x.1 y) (x.2 y) @ i)

-- Univalence expressed using Id everywhere:
univalenceId (A B : U) : equivId (Id U A B) (equivId A B) =
  equivToEquivId (Id U A B) (equivId A B) rem1
  where
  rem : Path U (Id U A B) (equivId A B) =
    compPath U (Id U A B) (equiv A B) (equivId A B)
             (IdUnivalence1 A B) (equivEquivIdU A B)
  rem1 : equiv (Id U A B) (equivId A B) =
    transEquiv' (equivId A B) (Id U A B) rem


{-
ua (A B : U) (e : equiv A B) : Path U A B =
  <i> Glue B [ (i = 0) -> (A,e)
             , (i = 1) -> (B,idEquiv B) ]

-- This does not work as before:
uabeta (A B : U) (e : equiv A B) : Path (A -> B) (trans A B (ua A B e)) e.1 = undefined 


-}
