module setquothit where

import univalence
import sigma
import nat
import propTrunc

hProp : U = (X : U) * prop X

rel (X : U) : U = X -> X -> U
hrel (X : U) : U = X -> X -> hProp

hsubtypes (X : U) : U = X -> hProp
carrier (X : U) (A : hsubtypes X) : U = (x : X) * (A x).1

propishinh (X : U) : prop (pTrunc X) = pTruncIsProp X

-- ishinh (X : U) : hProp = (ishinh_UU X,propishinh X)

ishinh (X : U) : hProp = (pTrunc X,pTruncIsProp X)

iseqclass (X : U) (R : hrel X) (A : hsubtypes X) : U =
  and (and (ishinh (carrier X A)).1
                   ((x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1))
          ((x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1)
propiseqclass (X : U) (R : hrel X) (A : hsubtypes X) : prop (iseqclass X R A) =

  propAnd (and (ishinh (carrier X A)).1
                          ((x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1))
                 ((x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1)
                 (propAnd (ishinh (carrier X A)).1
                                 ((x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1) p1 p2)
                 p3
  where
  p1 : prop (ishinh (carrier X A)).1 = propishinh (carrier X A)

  -- This proof is quite cool, but it looks ugly...
  p2 (f g : (x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1) :
   Path ((x1 x2 : X) -> (R x1 x2).1 -> (A x1).1 -> (A x2).1) f g =
    <i> \(x1 x2 : X) (h1 : (R x1 x2).1) (h2 : (A x1).1) ->
         (A x2).2 (f x1 x2 h1 h2) (g x1 x2 h1 h2) @ i

  p3 (f g : (x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1) :
    Path ((x1 x2 : X) -> (A x1).1 -> (A x2).1 -> (R x1 x2).1) f g =
   <i> \(x1 x2 : X) (h1 : (A x1).1) (h2 : (A x2).1) ->
        (R x1 x2).2 (f x1 x2 h1 h2) (g x1 x2 h1 h2) @ i

isrefl (X : U) (R : hrel X) : U = (x : X) -> (R x x).1
issymm (X : U) (R : hrel X) : U = (x1 x2 : X) -> (R x1 x2).1 -> (R x2 x1).1
istrans (X : U) (R : hrel X) : U =
  (x1 x2 x3 : X) -> (R x1 x2).1 -> (R x2 x3).1 -> (R x1 x3).1

ispreorder (X : U) (R : hrel X) : U = and (istrans X R) (isrefl X R)

iseqrel (X : U) (R : hrel X) : U = and (ispreorder X R) (issymm X R)

eqrel (X : U) : U = (R : hrel X) * (iseqrel X R)

eqrelrefl (X : U) (R : eqrel X) : isrefl X R.1 = R.2.1.2
eqrelsymm (X : U) (R : eqrel X) : issymm X R.1 = R.2.2
eqreltrans (X : U) (R : eqrel X) : istrans X R.1 = R.2.1.1


-- Set quotient of A by R
data setquot (A : U) (R : rel A) =
    setquotpr (a : A)
  | identification (a b : A) (r : R a b) <i>
      [ (i = 0) -> setquotpr a, (i = 1) -> setquotpr b ]
  -- | setTruncation (a b : setquot A R) (p q : Path (setquot A R) a b) <i j>
  --      [ (i = 0) -> p @ j
  --      , (i = 1) -> q @ j
  --      , (j = 0) -> a
  --      , (j = 1) -> b ]

identsetquot (A : U) (R : A -> A -> U) (a b : A) (r : R a b)
  : Path (setquot A R) (setquotpr a) (setquotpr b) =
    <i> identification {setquot A R} a b r @ i

setsetquot (A : U) (R : A -> A -> U) : set (setquot A R) = undefined
   -- \(a b : setquot A R) (p q : Path (setquot A R) a b) ->
   --   <i j> setTruncation {setquot A R} a b p q @ i @ j


setquotunivprop (X : U) (R : rel X) (P : setquot X R -> hProp)
  (ps : (x : X) -> (P (setquotpr x)).1) : (c : setquot X R) -> (P c).1 = split
  setquotpr a -> ps a
  identification a b r @ i ->
    let moo : Path (setquot X R) (setquotpr a) (setquotpr b) =
          identsetquot X R a b r
        moo1 : (P (setquotpr a)).1 = ps a
        moo2 : (P (setquotpr b)).1 = ps b
        asdf : Path U (P (setquotpr a)).1 (P (setquotpr b)).1 =
          <i> (P (moo @ i)).1
        argh : PathP asdf moo1 moo2 =
          lemPropF (setquot X R) (\(x : setquot X R) -> (P x).1)
            (\(x : setquot X R) -> (P x).2)
            (setquotpr a) (setquotpr b) moo (ps a) (ps b)
    in argh @ i
  -- setTruncation a b p q @ i j -> ?



setquotuniv2prop (X : U) (R : rel X) (P : setquot X R -> setquot X R -> hProp)
  (ps : (x x' : X) -> (P (setquotpr x) (setquotpr x')).1)
  (c c' : setquot X R) : (P c c').1 =
    setquotunivprop X R (\(c0' : setquot X R) -> P c c0')
      (\(x : X) -> setquotunivprop X R (\(c0 : setquot X R) -> P c0 (setquotpr x))
                     (\(x0 : X) -> ps x0 x) c) c'


-- lemPropF (A : U) (P : A -> U) (pP : (x : A) -> prop (P x)) (a0 a1 :A)
--          (p : Path A a0 a1) (b0 : P a0) (b1 : P a1) : PathP (<i>P (p@i)) b0 b1 =



-- shorthand for nat x nat
nat2 : U = and nat nat

natlemma (a b c d : nat) : Path nat (add (add a b) (add c d)) (add (add a d) (add c b)) =
  let rem : Path nat (add a (add b (add c d))) (add a (add d (add c b))) =
        <i> add a (add_comm3 b c d @ i)
  in <i> comp (<_> nat) (rem @ i) [ (i = 0) -> assocAdd a b (add c d)
                                  , (i = 1) -> assocAdd a d (add c b) ]

rel : eqrel nat2 = (r,rem)
  where
  r : hrel nat2 = \(x y : nat2) -> 
    (Path nat (add x.1 y.2) (add x.2 y.1),natSet (add x.1 y.2) (add x.2 y.1))
    
  rem : iseqrel nat2 r = ((rem1,rem2),rem3)
    where
    rem1 : istrans nat2 r =
     \(x y z : nat2) 
      (h1 : Path nat (add x.1 y.2) (add x.2 y.1))
      (h2 : Path nat (add y.1 z.2) (add y.2 z.1)) ->
      let rem : Path nat (add (add x.1 y.2) (add y.1 z.2)) (add (add x.2 y.1) (add y.2 z.1)) = 
           <i> add (h1 @ i) (h2 @ i)

          rem1 : Path nat (add (add x.1 y.2) (add y.1 z.2)) (add (add x.1 z.2) (add y.1 y.2)) =
            natlemma x.1 y.2 y.1 z.2

          rem2 : Path nat (add (add x.2 y.1) (add y.2 z.1)) (add (add x.2 z.1) (add y.2 y.1)) =
            natlemma x.2 y.1 y.2 z.1
          rem3 : Path nat (add (add x.2 z.1) (add y.2 y.1)) (add (add x.2 z.1) (add y.1 y.2)) = 
            <i> add (add x.2 z.1) (add_comm y.2 y.1 @ i)
          rem4 : Path nat (add (add x.2 y.1) (add y.2 z.1)) (add (add x.2 z.1) (add y.1 y.2)) =
            <i> comp (<_> nat) (add (add x.2 z.1) (add y.2 y.1)) [ (i = 0) -> <j> rem2 @ -j
                                                                 , (i = 1) -> rem3 ]

          rem5 : Path nat (add (add x.1 z.2) (add y.1 y.2)) (add (add x.2 z.1) (add y.1 y.2)) =
            <i> comp (<_> nat) (rem @ i) [ (i = 0) -> rem1, (i = 1) -> rem4 ]

      in natcancelr (add x.1 z.2) (add x.2 z.1) (add y.1 y.2) rem5
    rem2 : isrefl nat2 r = \(x : nat2) -> add_comm x.1 x.2
    rem3 : issymm nat2 r = \(x y : nat2) (h : Path nat (add x.1 y.2) (add x.2 y.1)) ->
      let rem : Path nat (add x.2 y.1) (add y.2 x.1) = 
            <i> comp (<_> nat) (add x.1 y.2) [ (i = 0) -> h
                                             , (i = 1) -> add_comm x.1 y.2 ]
      in <i> comp (<_> nat) (add x.2 y.1) [ (i = 0) -> add_comm x.2 y.1
                                          , (i = 1) -> rem ]

hz : U = setquot nat2 (\(x y : nat2) -> (rel.1 x y).1)
zeroz : hz = setquotpr (zero,zero)
onez : hz = setquotpr (one,zero)


isdecprop (X : U) : U = and (prop X) (dec X)

propisdecprop (X : U): prop (isdecprop X) =
  propSig (prop X) (\ (_ : prop X) -> dec X) rem1 rem2
  where
  rem1 : prop (prop X) = propIsProp X
  rem2 : prop X -> prop (dec X) = propDec X

isdeceqif (X : U) (h : (x x' : X) -> isdecprop (Path X x x')) : discrete X =
  \(x x' : X) -> (h x x').2


propEquiv (X Y : U) (w : equiv X Y) : prop X -> prop Y = subst U prop X Y rem
  where
  rem : Path U X Y = transport (<i> corrUniv X Y @ -i) w


isdecpropweqf (X Y : U) (w : equiv X Y) (hX : isdecprop X) : isdecprop Y = (rem1,rem2 hX.2)
  where
  rem1 : prop Y = propEquiv X Y w hX.1
  rem2 : dec X -> dec Y = split
    inl x -> inl (w.1 x)
    inr nx -> inr (\(y : Y) -> nx (invEq X Y w y))

isdecpropweqf (X Y : U) (w : equiv X Y) (hX : isdecprop X) : isdecprop Y = (rem1,rem2 hX.2)
  where
  rem1 : prop Y = propEquiv X Y w hX.1
  rem2 : dec X -> dec Y = split
    inl x -> inl (w.1 x)
    inr nx -> inr (\(y : Y) -> nx (invEq X Y w y))

subtypeEquality (A : U) (B : A -> U) (pB : (x : A) -> prop (B x))
                (s t : (x : A) * B x) : Path A s.1 t.1 -> Path (Sigma A B) s t =
  trans (Path A s.1 t.1) (Path (Sigma A B) s t) rem
    where
    rem : Path U (Path A s.1 t.1) (Path (Sigma A B) s t) =
      <i> lemSigProp A B pB s t @ -i

-- identsetquot (A : U) (R : A -> A -> U) (a b : A) (r : R a b)
--   : Path (setquot A R) (setquotpr a) (setquotpr b) =
--     <i> identification {setquot A R} a b r @ i

-- This used to be tricky to prove! Is eqrel really needed????
iscompsetquotpr (X : U) (R : eqrel X) (x x' : X) (a : (R.1 x x').1) :
  Path (setquot X (\(a b : X) -> (R.1 a b).1)) (setquotpr x) (setquotpr x') =
  identsetquot X (\(a b : X) -> (R.1 a b).1) x x' a

isEquivprop (A B : U) (f : A -> B) (g : B -> A) (pA : prop A) (pB : prop B) : isEquiv A B f = rem
  where
  rem (y : B) : isContr (fiber A B f y) = (s,t)
    where
    s : fiber A B f y = (g y,pB y (f (g y)))
    t (w : fiber A B f y) : Path ((x :  A) * Path B y (f x)) s w =
      subtypeEquality A (\(x : A) -> Path B y (f x)) pb s w r1
       where
       pb (x : A) : (a b : Path B y (f x)) -> Path (Path B y (f x)) a b = propSet B pB y (f x)
       r1 : Path A s.1 w.1 = pA s.1 w.1

weqpathsinsetquot (X : U) (R : eqrel X) (x x' : X) :
  equiv (R.1 x x').1
    (Path (setquot X (\(a b : X) -> (R.1 a b).1)) (setquotpr x) (setquotpr x')) =
  (iscompsetquotpr X R x x',rem)
  where
  rem : isEquiv (R.1 x x').1
                (Path (setquot X (\(a b : X) -> (R.1 a b).1)) (setquotpr x) (setquotpr x'))
                (iscompsetquotpr X R x x') = 
    isEquivprop (R.1 x x').1
                (Path (setquot X (\(a b : X) -> (R.1 a b).1)) (setquotpr x) (setquotpr x'))
                (iscompsetquotpr X R x x')
                g pA pB
   where g (e : Path (setquot X (\(a b : X) -> (R.1 a b).1)) (setquotpr x) (setquotpr x')) :
             (R.1 x x').1 = transport (<i> (rem1 @ i).1) rem
           where
           rem : (R.1 x' x').1 = eqrelrefl X R x'
           rem2 : Path hProp (R.1 x x') (R.1 x' x') = undefined -- <i> (e @ i).1 x'
           rem1 : Path hProp (R.1 x' x') (R.1 x x') = <i> rem2 @ -i
         pA : prop (R.1 x x').1 = (R.1 x x').2
         pB : prop (Path (setquot X (\(a b : X) -> (R.1 a b).1)) (setquotpr x) (setquotpr x')) = setsetquot X (\(a b : X) -> (R.1 a b).1) (setquotpr x) (setquotpr x')
    

isdiscretesetquot (X : U) (R' : eqrel X) (is : (x x' : X) -> isdecprop (R'.1 x x').1) :
  discrete (setquot X (\(a b : X) -> (R'.1 a b).1)) = isdeceqif (setquot X R) rem
  where
  R (a b : X) : U = (R'.1 a b).1
  rem : (x x' : setquot X R) -> isdecprop (Path (setquot X R) x x') = 
    setquotuniv2prop X R
      (\(x0 x0' : setquot X R) -> (isdecprop (Path (setquot X R) x0 x0'),
                                     propisdecprop (Path (setquot X R) x0 x0'))) rem'
    where
    rem' (x0 x0' : X) : isdecprop (Path (setquot X R) (setquotpr x0) (setquotpr x0')) =
      isdecpropweqf (R'.1 x0 x0').1 (Path (setquot X R) (setquotpr x0) (setquotpr x0'))
                    (weqpathsinsetquot X R' x0 x0') (is x0 x0')

discretetobool (X : U) (h : discrete X) (x y : X) : bool = rem (h x y)
  where
  rem : dec (Path X x y) -> bool = split
    inl _ -> true
    inr _ -> false


discretehz : discrete hz = isdiscretesetquot nat2 rel rem
  where
  rem (x y : nat2) : isdecprop (rel.1 x y).1 = 
    (natSet (add x.1 y.2) (add x.2 y.1),natDec (add x.1 y.2) (add x.2 y.1))

-- Use the decision procedure to compute if "0 = 1":
test01 : bool = discretetobool hz discretehz zeroz onez
