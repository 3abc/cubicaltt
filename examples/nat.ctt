module nat where

data nat = zero | suc (n : nat)

zero' : nat = zero
one : nat = suc zero
two : nat = suc one

pred : nat -> nat = split
  zero -> zero
  suc n -> n

add (m : nat) : nat -> nat = split
  zero  -> m
  suc n -> suc (add m n)

add' : nat -> nat -> nat = split
  zero -> \(x : nat) -> x
  suc n -> \(x : nat) -> suc (add' n x)

id (A : U) (a : A) : A = a

data list (A : U) = nil | cons (a : A) (as : list A)

l : list nat = cons one (cons two nil)

append (A : U) : list A -> list A -> list A = split
  nil -> id (list A)
  cons x xs -> \(ys : list A) -> cons x (append A xs ys)

reverse (A : U) : list A -> list A = split
  nil -> nil
  cons x xs -> append A (reverse A xs) (cons x nil)

Id (A : U) (a0 a1 : A) : U = IdP (<i> A) a0 a1

refl (A : U) (a : A) : Id A a a = <i> a

mapOnPath (A B : U) (f : A -> B) (a b : A)
          (p : Id A a b) : Id B (f a) (f b) = <i> f (p @ i)

funExt (A : U) (B : A -> U) (f g : (x : A) -> B x)
       (p : (x : A) -> Id (B x) (f x) (g x)) :
       Id ((y : A) -> B y) f g = <i> \(a : A) -> (p a) @ i

idnat : nat -> nat = split
  zero -> zero
  suc n -> suc (idnat n)

test : Id (nat -> nat) idnat (id nat) = funExt nat (\(_ : nat) -> nat) idnat (id nat) rem
  where
  rem : (n : nat) -> Id nat (idnat n) n = split
    zero -> refl nat zero
    suc n -> mapOnPath nat nat (\(x : nat) -> suc x) (idnat n) n (rem n)

subst (A : U) (P : A -> U) (a b : A) (p : Id A a b) (e : P a) : P b =
  transport (mapOnPath A U P a b p) e

substRefl (A : U) (P : A -> U) (a : A) (e : P a) : Id (P a) (subst A P a a (refl A a) e) e =
  refl (P a) e

singl (A : U) (a : A) : U = (x : A) * Id A a x

contrSingl (A : U) (a b : A) (p : Id A a b) :
  Id (singl A a) (a,refl A a) (b,p) = <i> (p @ i,<j> p @ i /\ j)

J (A : U) (a : A) (C : (x : A) -> Id A a x -> U)
  (d : C a (refl A a)) (x : A) (p : Id A a x) : C x p =
    subst (singl A a) T (a, refl A a) (x, p) (contrSingl A a x p) d
      where T (z : singl A a) : U = C (z.1) (z.2)

defEqJ (A : U) (a : A) (C : (x : A) -> Id A a x -> U) (d : C a (refl A a)) :
       Id (C a (refl A a)) (J A a C d a (refl A a)) d = refl (C a (refl A a)) d

test0 (A : U) (a b : A) (p : Id A a b) : Id A a a = refl A (p @ 0)
test1 (A : U) (a b : A) (p : Id A a b) : Id A b b = refl A (p @ 1)

compEmpty (A : U) (a b : A) (p : Id A a b) : Id A a b =
  <i> comp A (p @ i) [ ]

compId (A : U) (a b c : A) (p : Id A a b) (q : Id A b c) : Id A a c =
  <i> comp A (p @ i) [ (i = 1) -> q ]

kan (A : U) (a b c d : A) (p : Id A a b) (q : Id A a c)
                          (r : Id A b d) : Id A c d =
  <i> comp A (p @ i) [ (i = 0) -> q, (i = 1) -> r ]

inv (A : U) (a b : A) (p : Id A a b) : Id A b a = <i> p @ -i

-- lemSimpl (A : U) (a b c : A) (p : Id A a b) (q q' : Id A b c)
--          (s : Id (Id A a c) (compId A a b c p q) (compId A a b c p q')) : Id (Id A b c) q q' =
--   <j> <k> comp A a [ (j = 0) -> ... ]

-- evalPN (i:j:k:_) LemSimpl [v,a,b,c,p,q,q',s] =
--   Path j $ Path k $ comp Pos i v ss a
--    where ss = mkSystem [(j ~> 0,fill Pos k v (mkSystem [(i ~> 0,a),(i ~> 1,q @@ j)]) (p @@ i)),
--                         (j ~> 1,fill Pos k v (mkSystem [(i ~> 0,a),(i ~> 1,(q' @@ j))]) (p @@ i)),
--                         (k ~> 0,p @@ i),
--                         (k ~> 1,(s @@ j) @@ i)]



--         u
--    a0 ----- a1
--    |        |
-- r0 |        | r1
--    |        |
--    b0 ----- b1
--         v

Square (A : U) (a0 a1 : A) (u : Id A a0 a1)
               (b0 b1 : A) (v : Id A b0 b1)
               (r0 : Id A a0 b0) (r1 : Id A a1 b1) : U
  = IdP (<i> (IdP (<j> A) (u @ i) (v @ i))) r0 r1

testSquare (A : U) (a : A) (p : Id A a a) : Square A a a p a a p p p =
  <i j> comp A a
     [(i = 0) -> <k> p @ (j \/ - k),
      (i = 1) -> <k> p @ (j /\ k),
      (j = 0) -> <k> p @ (i \/ - k),
      (j = 1) -> <k> p @ (i /\ k)]