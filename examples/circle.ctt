-- The circle as a HIT.
module circle where

import bool
import int

data S1 = base
        | loop <i> [ (i=0) -> base
                   , (i=1) -> base]

loopS1 : U = Path S1 base base

loop1 : loopS1 = <i> loop{S1} @ i

invLoop : loopS1 = inv S1 base base loop1

moebius : S1 -> U = split
  base -> bool
  loop @ i -> negBoolEq @ i

helix : S1 -> U = split
  base -> Z
  loop @ i -> sucPathZ @ i

winding (p : loopS1) : Z = trans Z Z rem zeroZ
  where
    rem : Path U Z Z = <i> helix (p @ i)

compS1 : loopS1 -> loopS1 -> loopS1 = compPath S1 base base base

-- All of these should be equal to "posZ (suc zero)":
loop2 : loopS1 = compS1 loop1 loop1
loop2' : loopS1 = compPath' S1 base base base loop1 loop1
loop2'' : loopS1 = compPath'' S1 base base loop1 base loop1

-- More examples:
loopZ1  : Z = winding loop1
loopZ2  : Z = winding (compS1 loop1 loop1)
loopZ3  : Z = winding (compS1 loop1 (compS1 loop1 loop1))
loopZN1 : Z = winding invLoop
loopZ0  : Z = winding (compS1 loop1 invLoop)
loopZ5  : Z = winding (compS1 loop1 (compS1 loop1 (compS1 loop1 (compS1 loop1 loop1))))

mLoop : (x : S1) -> Path S1 x x = split
  base -> loop1
  loop @ i -> constSquare S1 base loop1 @ i

mult (x : S1) : S1 -> S1 = split
  base -> x
  loop @ i -> mLoop x @ i

square (x : S1) : S1 = mult x x

doubleLoop (l : loopS1) : loopS1 = <i> square (l @ i)
tripleLoop (l : loopS1) : loopS1 = <i> mult (l @ i) (square (l @ i))

loopZ4 : Z = winding (doubleLoop (compS1 loop1 loop1))
loopZ8 : Z = winding (doubleLoop (doubleLoop (compS1 loop1 loop1)))

triv : loopS1 = <i> base

-- A nice example of a homotopy on the circle. The path going halfway
-- around the circle and then back is contractible:
hmtpy : Path loopS1 (<i> base) (<i> loop{S1} @ (i /\ -i)) =
  <j i> loop{S1} @ j /\ i /\ -i

circleelim (X : U) (x : X) (p : Path X x x) : S1 -> X = split
  base -> x
  loop @ i -> p @ i

apcircleelim (A B : U) (x : A) (p : Path A x x) (f : A -> B) :
  (z : S1) -> Path B (f (circleelim A x p z))
                   (circleelim B (f x) (<i> f (p @ i)) z) = split
   base -> <_> f x
   loop @ i -> <_> f (p @ i)


-- a special case, Lemmas 6.2.5-6.2.9 in the book

aLoop (A:U) : U = (a:A) * Path A a a

phi (A:U) (al : aLoop A) : S1 -> A = split
  base -> al.1
  loop @ i -> (al.2)@ i

psi (A:U) (f:S1 -> A) : aLoop A = (f base,<i>f (loop1@i))

rem (A:U) (f : S1 -> A) : (u : S1) -> Path A (phi A (psi A f) u) (f u) = split
         base -> refl A (f base)
         loop @ i -> <j>f (loop1@i)

lem (A:U) (f : S1 -> A) : Path (S1 -> A) (phi A (psi A f)) f = 
 <i> \ (x:S1) -> (rem A f x) @ i

thm (A:U) : Path U (aLoop A) (S1 -> A) = isoPath T0 T1 f g t s
 where T0 : U = aLoop A
       T1 : U = S1 -> A
       f : T0 -> T1 = phi A
       g : T1 -> T0 = psi A
       s (x:T0) : Path T0 (g (f x)) x    = refl T0 x
       t : (y:T1) -> Path T1 (f (g y)) y = lem A

bignumber : nat =
 suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc (suc zero))))))))))))))))))))))))))))))))))))))))))))))))))


-- Some benchmarks:

loopcap : nat -> Path S1 base base = split
  zero -> <_> base
  suc n -> <i> hcomp S1 (loopcap n @ i) [ (i=0) -> <_> base, (i=1) -> loop1 ]

loopleft : nat -> Path S1 base base = split
  zero -> <_> base
  suc n -> <i> hcomp S1 (loop1 @ i) [ (i=0) -> <i> loopleft n @ -i, (i=1) -> <_> base ]

loopright : nat -> Path S1 base base = split
  zero -> <_> base
  suc n -> <i> hcomp S1 (loop1 @ i) [ (i=0) -> <_> base, (i=1) -> loopright n ]

-- These are instant:
nloopleft10 : Z = winding (loopleft n10)
nloopcap10 : Z = winding (loopcap n10)
nloopright10 : Z = winding (loopright n10)


nloopleft128 : Z = winding (loopleft n128)
-- > nloopleft128
-- EVAL: inr (suc ...)
-- Time: 0m0.133s

nloopcap128 : Z = winding (loopcap n128)
-- > nloopright128
-- EVAL: inr (suc ...)
-- Time: 0m0.069s

nloopright128 : Z = winding (loopright n128)
-- > nloopcap128
-- EVAL: inr (suc ...)
-- Time: 0m0.142s


nloopleft256 : Z = winding (loopleft n256)
-- > nloopcap256 
-- EVAL: inr (suc ...)
-- Time: 0m0.683s

nloopcap256 : Z = winding (loopcap n256)
-- > nloopcap256 
-- EVAL: inr (suc ...)
-- Time: 0m0.220s

nloopright256 : Z = winding (loopright n256)
-- > nloopright256
-- EVAL: inr (suc ...)
-- Time: 0m0.649s

nloopright512 : Z = winding (loopright n512)
-- > nloopright512 
-- EVAL: inr (suc ...)
-- Time: 0m3.102s

nloopleft512 : Z = winding (loopleft n512)
-- > nloopleft512
-- EVAL: inr (suc ...)
-- Time: 0m3.257s

nloopcap512 : Z = winding (loopcap n512)
-- > nloopcap512 
-- EVAL: inr (suc ...)
-- Time: 0m0.562s


nloopleft1024 : Z = winding (loopleft n1024)
-- > nloopleft1024
-- EVAL: inr (suc ...)
-- Time: 0m13.794s

nloopright1024 : Z = winding (loopright n1024)
-- > nloopright1024
-- EVAL: inr (suc ...)
-- Time: 0m16.091s

nloopcap1024 : Z = winding (loopcap n1024)
-- > nloopcap1024
-- EVAL: inr (suc ...)
-- Time:  0m3.607s




-- Here is a version of loopright where the second branch has been
-- eta-expanded:
looprighteta : nat -> Path S1 base base = split
  zero -> <_> base
  suc n -> <i> hcomp S1 (loop1 @ i) [ (i=0) -> <_> base, (i=1) -> <j> looprighteta n @ j ]

-- After adding closures for Path-lambdas they compute the same way
-- (looprighteta was a lot slower before):

-- > winding (loopright n256) Time: 0m0.494s
-- EVAL: inr (suc ...)
-- Time: 0m0.733s

-- > winding (looprighteta n256)
-- EVAL: inr (suc ...)
-- Time: 0m0.745s


-- More involved examples:

-- This is always "inr (suc zero)" (the loops on the LHS cancel the
-- ones on the RHS), but the input grows 3^n
loopall : nat -> Path S1 base base = split
  zero -> loop1
  suc n -> <i> hcomp S1 (loopall n @ i) [ (i=0) -> loopall n
                                        , (i=1) -> loopall n ]
-- > winding (loopall n9)
-- EVAL: inr (suc zero)
-- Time:  0m3.583s
-- The input here is 3^9 = 19683


-- This computes 3^n
loop3n : nat -> Path S1 base base = split
  zero -> loop1
  suc n -> <i> hcomp S1 (loop3n n @ i) [ (i=0) -> <j> loop3n n @ -j
                                       , (i=1) -> loop3n n ]

-- > winding (loop3n n6)     (3^6 = 729)
-- EVAL: inr (suc ...)
-- Time: 0m1.181s

-- > winding (loop3n n7)     (3^7 = 2187)
-- EVAL: inr (suc ...)
-- Time: 0m14.146s


