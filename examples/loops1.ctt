-- This file contains two self-contained proofs that the loop space of
-- S1 is a set. They both first prove that the loop space of S1 is a
-- retract of Z and then that a retract of a set is a set. The first
-- proof is called setLoop' and the second setLoop.

-- The first proof uses a version of decode that is heavily dependent
-- on exactly how transport in Glue is defined (one has to remove
-- hcomp's by hand) while the second is a more direct definition which
-- should be more robust and efficient. The latter proof is inspired
-- by: https://github.com/RedPRL/redtt/blob/master/example/omega1s1.red

module loops1 where

idfun (A : U) (a : A) : A = a

Path (A : U) (a0 a1 : A) : U = PathP (<i> A) a0 a1

--         v
--    b0 -----> b1
--    |         |
--    |         |
-- r0 |         | r1
--    |         |
--    a0 -----> a1
--         u
Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (Path A (u @ i) (v @ i))) r0 r1

fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)
isContr (A : U) : U = (x : A) * ((y : A) -> Path A x y)
prop (A : U) : U = (a b : A) -> Path A a b
set (A : U) : U = (a b : A) -> prop (Path A a b)

isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)

equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

contrSingl (A : U) (a b : A) (p : Path A a b) :
  Path ((x : A) * Path A a x) (a,<_>a) (b,p) = <i> (p @ i,<j> p @ i/\j)

idIsEquiv (A : U) : isEquiv A A (idfun A) =
  \(a : A) -> ((a,<_>a),\(z : (x : A) * Path A a x) -> contrSingl A a z.1 z.2)

idEquiv (A : U) : equiv A A = (idfun A,idIsEquiv A)

ua (A B : U) (e : equiv A B) : Path U A B =
  <i> Glue B [ (i = 0) -> (A,e)
             , (i = 1) -> (B,idEquiv B) ]

subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transGen (<i> P (p @ i)) 0 e

J (A : U) (a : A) (C : (x : A) -> Path A a x -> U)
  (d : C a (<_> a)) (x : A) (p : Path A a x) : C x p =
    subst ((x : A) * Path A a x) T (a,<_> a) (x, p) (contrSingl A a x p) d
      where T (z : (x : A) * Path A a x) : U = C (z.1) (z.2)

compPath (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c =
  <i> hcomp A (p @ i) [ (i =0) -> <j> a, (i = 1) -> q ]


compInvPath (A : U) (a b : A) (p : Path A a b) :
  Path (Path A b b) (compPath A b a b (<i> p @ -i) p)  (<_> b) =
   <j i> hcomp A (p @ -i \/ j)
                 [ (i = 0) -> <_> b
                 , (j = 1) -> <_> b
                 , (i = 1) -> <k> p @ j \/ k ]

data nat = zero | suc (n : nat)

idfun (A : U) (a : A) : A = a

pred : nat -> nat = split
  zero -> zero
  suc n -> n


{- Z is represented as:

  +2 = pos (suc (suc zero))
  +1 = pos (suc zero)
   0 = pos zero
  -1 = neg zero
  -2 = neg (suc zero)

-}
data Z = pos (n : nat) | neg (n : nat)

zeroZ : Z = pos zero

data N0 =

not (A : U) : U = A -> N0
efq (A : U) : N0 -> A = split {}

-- Direct proof that Z is a set:
invP : (n m : nat) (p : Path nat n m) -> U = split
  zero  -> split@((m : nat) (p : Path nat zero m) -> U) with
    zero  -> \(p : Path nat zero zero) -> 
               Path (Path nat zero zero) p (<_> zero)
    suc m -> \(p : Path nat zero (suc m)) -> N0
  suc n -> split@((m : nat) (p : Path nat (suc n) m) -> U) with
    zero  -> \(p : Path nat (suc n) zero) -> N0
    suc m -> \(p : Path nat (suc n) (suc m)) ->
               Path (Path nat (suc n) (suc m)) p (<i> suc (pred (p @ i)))

-- using J for now
pinv : (n m : nat) (p : Path nat n m) -> invP n m p = split
  zero  -> J nat zero (invP zero) (<_ _> zero)
  suc n -> J nat (suc n) (invP (suc n)) (<_ _> suc n)

lem : (n : nat) (p : Path nat n n) -> Path (Path nat n n) p (<_> n) = split
  zero  -> pinv zero zero
  suc n -> \(p : Path nat (suc n) (suc n)) ->
               compPath (Path nat (suc n) (suc n)) p (<i> suc (pred (p @ i))) (<_> suc n)
                 (pinv (suc n) (suc n) p)
                 (<i j> suc (lem n (<k> pred (p @ k)) @ i @ j))

natset' (n : nat) : (m : nat) (p q : Path nat n m) -> Path (Path nat n m) q p = 
  J nat n (\(m : nat)(p : Path nat n m) ->
            (q : Path nat n m) -> Path (Path nat n m) q p)
    (lem n)
  
setnat (n m : nat) (p q : Path nat n m) : Path (Path nat n m) p q = natset' n m q p

invZ : (u v : Z) (p : Path Z u v) -> U = split
  pos a -> split@((v : Z) -> (p : Path Z (pos a) v) -> U) with
    pos a' -> \(p : Path Z (pos a) (pos a')) ->
              (q : Path nat a a') * (Path (Path Z (pos a) (pos a')) p (<i> pos (q @ i)))
    neg b' -> \(p : Path Z (pos a) (neg b')) -> N0
  neg b -> split@((v : Z) -> (p : Path Z (neg b) v) -> U) with
    pos a' -> \(p : Path Z (neg b) (pos a')) -> N0
    neg b' -> \(p : Path Z (neg b) (neg b')) ->
              (q : Path nat b b') * (Path (Path Z (neg b) (neg b')) p (<i> neg (q @ i)))

pinvZ : (u v : Z) (p : Path Z u v) -> invZ u v p = split
  pos a -> J Z (pos a) (invZ (pos a)) (<_> a,<_ _> pos a)
  neg b -> J Z (neg b) (invZ (neg b)) (<_> b,<_ _> neg b)

lemZ : (u : Z) (p : Path Z u u) -> Path (Path Z u u) p (<_> u) = split
  pos a -> \(p : Path Z (pos a) (pos a)) -> 
    let qa : invZ (pos a) (pos a) p = pinvZ (pos a) (pos a) p
    in compPath (Path Z (pos a) (pos a)) p (<i> pos (qa.1 @ i)) (<_> pos a) qa.2
                (<i j> pos (setnat a a qa.1 (<_> a) @ i @ j))
  neg b -> \(p : Path Z (neg b) (neg b)) -> 
    let qb : invZ (neg b) (neg b) p = pinvZ (neg b) (neg b) p
    in compPath (Path Z (neg b) (neg b)) p (<i> neg (qb.1 @ i)) (<_> neg b) qb.2
                (<i j> neg (setnat b b qb.1 (<_> b) @ i @ j))

setZ' (u : Z) : (v : Z) (p q : Path Z u v) -> Path (Path Z u v) q p =
  J Z u (\(v : Z) (p : Path Z u v) -> (q : Path Z u v) -> Path (Path Z u v) q p)
    (lemZ u)

ZSet (u v : Z) (p q : Path Z u v) : Path (Path Z u v) p q = setZ' u v q p

-- sucZ is an equiv:

sucZ : Z -> Z = split
  pos u -> pos (suc u)
  neg v -> auxsucZ v
    where
    auxsucZ : nat -> Z = split
      zero  -> pos zero
      suc n -> neg n

auxpredZ : nat -> Z = split
  zero  -> neg zero
  suc n -> pos n

predZ : Z -> Z = split
  pos u -> auxpredZ u
  neg v -> neg (suc v)

predsucZ : (x : Z) -> Path Z (predZ (sucZ x)) x = split
  pos u -> <_> pos u
  neg v -> lem v
   where
    lem : (u : nat) -> Path Z (predZ (sucZ (neg u))) (neg u) = split
      zero  -> <_> neg zero
      suc n -> <_> neg (suc n)

sucpredZ : (x : Z) -> Path Z (sucZ (predZ x)) x = split
  pos u -> lem u
   where
    lem : (u : nat) -> Path Z (sucZ (predZ (pos u))) (pos u) = split
      zero  -> <_> pos zero
      suc n -> <_> pos (suc n)
  neg v -> <_> neg v

-- Maybe we can generalize the notion of being a set to allow
-- arbitrary paths on the sides and not just refl?
gengoal (A : U) (hA : set A) (x y : A) (p : Path A x y) : (z : A) (r : Path A y z) (q : Path A x z) ->
  PathP (<i> Path A x (r @ i)) p q =
  J A y (\(z : A) (r : Path A y z) -> (q : Path A x z) -> PathP (<i> Path A x (r @ i)) p q)
   (hA x y p)

ctr (y : Z) : fiber Z Z sucZ y = (predZ y,<i> sucpredZ y @ -i)

contr (y : Z) (y' : fiber Z Z sucZ y) : Path ((x : Z) * Path Z y (sucZ x)) (ctr y) y' =
    let p1 : Path Z (predZ y) y'.1 =
          compPath Z (predZ y) (predZ (sucZ y'.1)) y'.1
                   (<i> predZ (y'.2 @ i)) (predsucZ y'.1)
        prf1 : Path Z (sucZ (predZ y)) (sucZ y'.1) = <i> sucZ (p1 @ i)
        prf2 : Path Z y (sucZ (predZ y)) = <i> sucpredZ y @ -i
        p2 : PathP (<i> Path Z y (prf1 @ i)) prf2 y'.2 =
          gengoal Z ZSet y (sucZ (predZ y)) prf2 (sucZ y'.1) prf1 y'.2
    in <i> (p1 @ i,p2 @ i)

equivSucZ : isEquiv Z Z sucZ = \(y : Z) -> (ctr y,contr y)
    
sucPathZ : Path U Z Z = ua Z Z (sucZ,equivSucZ)

-- We now prove that "decode x (encode x p) = p" so that we get that
-- loopS1 is a retract of Z

data S1 = base1
        | loop1 <i> [ (i=0) -> base1
                    , (i=1) -> base1 ]
loopS1 : U = Path S1 base1 base1
loop : loopS1 = <i> loop1{S1} @ i
invLoop : loopS1 = <i> loop @ -i
compS1 : loopS1 -> loopS1 -> loopS1 = compPath S1 base1 base1 base1

-- Covering space of the circle
helix : S1 -> U = split
  base1 -> Z
  loop1 @ i -> sucPathZ @ i

encode (x : S1) (p : Path S1 base1 x) : helix x =
  subst S1 helix base1 x p zeroZ

-- loop^n
loopPos : nat -> loopS1 = split
  zero -> <_> base1
  suc n -> compS1 (loopPos n) loop

loopNeg : nat -> loopS1 = split
  zero -> invLoop
  suc n -> compS1 (loopNeg n) invLoop

loopIt : (n : Z) -> loopS1 = split
  pos n -> loopPos n
  neg n -> loopNeg n


-------------------------------------------------------------------------------
-- We now define decode'

shiftPos : (n : nat) -> Path loopS1 (compS1 (loopIt (predZ (pos n))) loop) (loopIt (pos n)) = split
  zero -> compInvPath S1 base1 base1 loop
  suc n -> <_ i> hcomp S1 (loopPos n @ i) [ (i = 0) -> <_> base1, (i = 1) -> loop ]

shiftNeg (n : nat) : Path loopS1 (compS1 (loopIt (predZ (neg n))) loop) (loopIt (neg n)) =
  <j i> hcomp S1 (hfill S1 (loopNeg n @ i) [ (i = 0) -> <_> base1, (i = 1) -> <j> loop @ -j ] @ -j)
                  [ (i = 0) -> <_> base1
                  , (i = 1) -> <k> loop @ j \/ k
                  , (j = 1) -> <k> loopNeg n @ i ]

-- it is important that the loop is appended as this is what the subst will do below
shift : (n : Z) -> Path loopS1 (compS1 (loopIt (predZ n)) loop) (loopIt n) = split
  pos n -> shiftPos n
  neg n -> shiftNeg n

-- Compose 3 paths. This is a little bit more compact than doing 2 compPath
comp3 (A : U) (a b c d : A) (p : Path A a b) (q : Path A b c) (r : Path A c d) : Path A a d =
  <i> hcomp A (q @ i) [ (i = 0) -> <j> p @ -j, (i = 1) -> r ]

hcompbase (p : loopS1) : loopS1 =
  <i> hcomp S1 (p @ i) [ (i = 0) -> <_> base1, (i = 1) -> <_> base1 ]
  
hcompbaseeq (p : loopS1) : Path loopS1 (hcompbase p) p =
  <j i> hcomp S1 (p @ i /\ -j) [ (i = 0) -> <_> base1
                               , (i = 1) -> <k> p @ -j \/ k
                               , (j = 1) -> <k> p @ i /\ k ]

hcompbaseeq2 (p : loopS1) : Path loopS1 (hcompbase (hcompbase p)) p =
  let sq1 : Path loopS1 (hcompbase p) p = hcompbaseeq p
      sq2 : Path loopS1 (hcompbase (hcompbase p)) (hcompbase p) =
              hcompbaseeq (hcompbase p)
  in compPath loopS1 (hcompbase (hcompbase p)) (hcompbase p) p sq2 sq1

-- This proof requires that "transGen (<_> nat) 0 n == n" judgmentally as it is done now
-- This proof requires that "transGen (<_> S1) 0 n == n" judgmentally as it is done now
decodeLoop (n : Z) :
  Path (Path S1 base1 base1)
  (subst S1 (\(x : S1) -> helix x -> Path S1 base1 x) base1 base1 loop loopIt n)
  (loopIt n) =
      let T (p : loopS1) : loopS1 =
            (<i> hcomp S1 (hcomp S1 (hcomp S1 (p @ i)
                                              [ (i = 0) -> <_> base1
                                              , (i = 1) -> <_> base1 ])
                                    [ (i = 0) -> <_> base1
                                   , (i = 1) -> <_> base1 ])
                          [ (i = 0) -> <_> base1
                          , (i = 1) -> loop ])
                      
          key (p : loopS1) : Path loopS1 (T p) (compS1 p loop) =
            <i> compS1 (hcompbaseeq2 p @ i) loop

          goal : Path loopS1 (T (loopIt (predZ n))) (loopIt n) =
                      compPath loopS1 (T (loopIt (predZ n)))
                        (compS1 (loopIt (predZ n)) loop) (loopIt n)
                        (key (loopIt (predZ n))) (shift n)
      in goal

-- Specialized version of pathSIntro for S1
pathSIntroS1 (C : S1 -> U) (c : C base1)
           (w : Path (C base1) (subst S1 C base1 base1 loop c) c) :
  PathP (<i> C (loop @ i)) c c =
  transGen (<j> PathP (<i> C (loop @ -j \/ i))
                      (transGen (<i> C (loop @ -j /\ i)) j c) c) 0 w

s1elim (C : S1 -> U) (c : C base1) (p : Path (C base1) (subst S1 C base1 base1 loop c) c) :
  (x : S1) -> C x = split
  base1 -> c
  loop1 @ i -> pathSIntroS1 C c p @ i

decode' : (x : S1) -> helix x -> Path S1 base1 x =
  s1elim (\(x : S1) -> helix x -> Path S1 base1 x) loopIt (<i> \(x : Z) -> decodeLoop x @ i)

decodeEncode' (x : S1) (p : Path S1 base1 x) : Path (Path S1 base1 x) (decode' x (encode x p)) p =
  transGen (<i> Path (Path S1 base1 (p @ i))
                     (decode' (p @ i) (encode (p @ i) (<j> p @ i /\ j)))
                     (<j> p @ i /\ j))
            0
            (<_ _> base1)


setLoop' (p q : loopS1) (r s : Path loopS1 p q) : Path (Path loopS1 p q) r s =
  let f : loopS1 -> Z = encode base1
      g : Z -> loopS1 = decode' base1
  in <j i> hcomp loopS1 (g (ZSet (f p) (f q) (<i> f (r @ i)) (<i> f (s @ i)) @ j @ i))
                        [ (i = 0) -> decodeEncode' base1 p
                        , (i = 1) -> decodeEncode' base1 q
                        , (j = 0) -> decodeEncode' base1 (r @ i)
                        , (j = 1) -> decodeEncode' base1 (s @ i) ]



-------------------------------------------------------------------------------
-- Can we do this directly without s1elim and pathSIntroS1? Yes!

decodeSquarePos : (n : nat) -> Square S1 base1 base1 base1 base1
                                      (<_> base1)
                                      loop
                                      (loopIt (predZ (pos n)))
                                      (loopIt (pos n)) = split
  zero -> <i j> loop @ i \/ -j
  suc n -> <i j> hfill S1 (loopPos n @ j) [ (j = 0) -> <_> base1
                                          , (j = 1) -> loop ] @ i

decodeSquareNeg (n : nat) : Square S1 base1 base1 base1 base1
                                   (<_> base1)
                                   loop
                                   (loopIt (predZ (neg n)))
                                   (loopIt (neg n)) =
  <i j> hcomp S1 (loopNeg n @ j)
                 [ (i=1) -> <_> loopNeg n @ j
                 , (j=0) -> <_> base1
                 , (j=1) -> <k> loop @ i \/ -k ]

decodeSquare : (n : Z) -> Square S1 base1 base1 base1 base1
                                 (<_> base1)
                                 loop
                                 (loopIt (predZ n))
                                 (loopIt n) = split
  pos n -> decodeSquarePos n
  neg n -> decodeSquareNeg n


decode : (x : S1) -> helix x -> Path S1 base1 x = split
  base1 -> loopIt
  loop1 @ i -> \(y : sucPathZ @ i) -> <j>
    let n : Z = unglue y Z [(i=0) -> (Z,(sucZ,equivSucZ))
                           ,(i=1) -> (Z,idEquiv Z)]
    in hcomp S1 (decodeSquare n @ i @ j)
                [ (j=0) -> <_> base1
                , (j=1) -> <_> loop @ i
                , (i=0) -> <k> loopIt (predsucZ y @ k) @ j
                , (i=1) -> <_> loopIt y @ j ]


decodeEncode (x : S1) (p : Path S1 base1 x) : Path (Path S1 base1 x) (decode x (encode x p)) p =
  transGen (<i> Path (Path S1 base1 (p @ i))
                     (decode (p @ i) (encode (p @ i) (<j> p @ i /\ j)))
                     (<j> p @ i /\ j))
            0
            (<_ _> base1)

setLoop (p q : loopS1) (r s : Path loopS1 p q) : Path (Path loopS1 p q) r s =
  let f : loopS1 -> Z = encode base1
      g : Z -> loopS1 = decode base1
  in <j i> hcomp loopS1 (g (ZSet (f p) (f q) (<i> f (r @ i)) (<i> f (s @ i)) @ j @ i))
                        [ (i = 0) -> decodeEncode base1 p
                        , (i = 1) -> decodeEncode base1 q
                        , (j = 0) -> decodeEncode base1 (r @ i)
                        , (j = 1) -> decodeEncode base1 (s @ i) ]


-- We now compare the normal forms:

-- Normal form of setLoop
nsetLoop (p q : loopS1) (r s : Path loopS1 p q) : Path (Path loopS1 p q) r s = 
  <i764 i765 i766> hcomp S1 (loopIt (ZSet (transGen (<i793> helix (p @ i793)) 0 (pos zero)) (transGen (<i792> helix (q @ i792)) 0 (pos zero)) (<i790> transGen (<i791> helix (r @ i790 @ i791)) 0 (pos zero)) (<i788> transGen (<i789> helix (s @ i788 @ i789)) 0 (pos zero)) @ i764 @ i765) @ i766) [ (i764 = 0) -> <i770> hcomp S1 base1 [ (i766 = 0) -> <i771> base1, (i766 = 1) -> <i771> r @ i765 @ i771, (i770 = 0) -> <i771> decode (r @ i765 @ i771) (transGen (<i772> helix (r @ i765 @ (i771 /\ i772))) 0 (pos zero)) @ i766, (i770 = 1) -> <i771> r @ i765 @ (i766 /\ i771) ], (i764 = 1) -> <i770> hcomp S1 base1 [ (i766 = 0) -> <i776> base1, (i766 = 1) -> <i776> s @ i765 @ i776, (i770 = 0) -> <i776> decode (s @ i765 @ i776) (transGen (<i777> helix (s @ i765 @ (i776 /\ i777))) 0 (pos zero)) @ i766, (i770 = 1) -> <i776> s @ i765 @ (i766 /\ i776) ], (i765 = 0) -> <i770> hcomp S1 base1 [ (i766 = 0) -> <i781> base1, (i766 = 1) -> <i781> p @ i781, (i770 = 0) -> <i781> decode (p @ i781) (transGen (<i782> helix (p @ (i781 /\ i782))) 0 (pos zero)) @ i766, (i770 = 1) -> <i781> p @ (i766 /\ i781) ], (i765 = 1) -> <i770> hcomp S1 base1 [ (i766 = 0) -> <i786> base1, (i766 = 1) -> <i786> q @ i786, (i770 = 0) -> <i786> decode (q @ i786) (transGen (<i787> helix (q @ (i786 /\ i787))) 0 (pos zero)) @ i766, (i770 = 1) -> <i786> q @ (i766 /\ i786) ], (i766 = 0) -> <i770> base1, (i766 = 1) -> <i770> base1 ]

-- Normal form of setLoop'
nsetLoop' (p q : loopS1) (r s : Path loopS1 p q) : Path (Path loopS1 p q) r s =
  <i800 i801 i802> hcomp S1 (loopIt (ZSet (transGen (<i901> helix (p @ i901)) 0 (pos zero)) (transGen (<i900> helix (q @ i900)) 0 (pos zero)) (<i898> transGen (<i899> helix (r @ i898 @ i899)) 0 (pos zero)) (<i896> transGen (<i897> helix (s @ i896 @ i897)) 0 (pos zero)) @ i800 @ i801) @ i802) [ (i800 = 0) -> <i806> hcomp S1 base1 [ (i802 = 0) -> <i807> base1, (i802 = 1) -> <i807> r @ i801 @ i807, (i806 = 0) -> <i807> s1elim (\(x : S1) -> (helix x) -> (PathP (<i809> S1) base1 x)) loopIt (<i810> \(x : Z) -> <i811> hcomp S1 (hcomp S1 (hcomp S1 (hcomp S1 (hcomp S1 (loopIt (predZ x) @ (-i810 /\ i811)) [ (i810 = 0)(i811 = 1) -> <i826> base1, (i810 = 1) -> <i826> base1, (i811 = 0) -> <i826> base1 ]) [ (i810 = 1) -> <i822> hcomp S1 (loopIt (predZ x) @ (i811 /\ i822)) [ (i811 = 0) -> <i823> base1, (i811 = 1)(i822 = 1) -> <i823> base1, (i822 = 0) -> <i823> base1 ], (i811 = 0) -> <i822> base1, (i811 = 1) -> <i822> hcomp S1 (loopIt (predZ x) @ (-i810 \/ i822)) [ (i810 = 0) -> <i825> base1, (i810 = 1)(i822 = 0) -> <i825> base1, (i822 = 1) -> <i825> base1 ] ]) [ (i810 = 0) -> <i818> hcomp S1 (hcomp S1 (loopIt (predZ x) @ i811) [ (i811 = 0) -> <i820> base1, (i811 = 1) -> <i820> base1 ]) [ (i811 = 0) -> <i819> base1, (i811 = 1) -> <i819> base1 ], (i810 = 1) -> <i818> hcomp S1 (loopIt (predZ x) @ (i811 /\ -i818)) [ (i811 = 0) -> <i821> base1, (i811 = 1) -> <i821> loopIt (predZ x) @ (-i818 \/ i821), (i818 = 1) -> <i821> loopIt (predZ x) @ (i811 /\ i821) ], (i811 = 0) -> <i818> base1, (i811 = 1) -> <i818> base1 ]) [ (i811 = 0) -> <i816> base1, (i811 = 1) -> <i816> loop1 {S1} @ i816 ]) [ (i810 = 0) -> <i812> hcomp S1 (hcomp S1 (hcomp S1 (loopIt (predZ x) @ i811) [ (i811 = 0) -> <i815> base1, (i811 = 1) -> <i815> base1 ]) [ (i811 = 0) -> <i814> base1, (i811 = 1) -> <i814> base1 ]) [ (i811 = 0) -> <i813> base1, (i811 = 1) -> <i813> loop1 {S1} @ i813 ], (i810 = 1) -> <i812> shift x @ i812 @ i811, (i811 = 0) -> <i812> base1, (i811 = 1) -> <i812> base1 ]) (r @ i801 @ i807) (transGen (<i808> helix (r @ i801 @ (i807 /\ i808))) 0 (pos zero)) @ i802, (i806 = 1) -> <i807> r @ i801 @ (i802 /\ i807) ], (i800 = 1) -> <i806> hcomp S1 base1 [ (i802 = 0) -> <i830> base1, (i802 = 1) -> <i830> s @ i801 @ i830, (i806 = 0) -> <i830> s1elim (\(x : S1) -> (helix x) -> (PathP (<i832> S1) base1 x)) loopIt (<i833> \(x : Z) -> <i834> hcomp S1 (hcomp S1 (hcomp S1 (hcomp S1 (hcomp S1 (loopIt (predZ x) @ (-i833 /\ i834)) [ (i833 = 0)(i834 = 1) -> <i849> base1, (i833 = 1) -> <i849> base1, (i834 = 0) -> <i849> base1 ]) [ (i833 = 1) -> <i845> hcomp S1 (loopIt (predZ x) @ (i834 /\ i845)) [ (i834 = 0) -> <i846> base1, (i834 = 1)(i845 = 1) -> <i846> base1, (i845 = 0) -> <i846> base1 ], (i834 = 0) -> <i845> base1, (i834 = 1) -> <i845> hcomp S1 (loopIt (predZ x) @ (-i833 \/ i845)) [ (i833 = 0) -> <i848> base1, (i833 = 1)(i845 = 0) -> <i848> base1, (i845 = 1) -> <i848> base1 ] ]) [ (i833 = 0) -> <i841> hcomp S1 (hcomp S1 (loopIt (predZ x) @ i834) [ (i834 = 0) -> <i843> base1, (i834 = 1) -> <i843> base1 ]) [ (i834 = 0) -> <i842> base1, (i834 = 1) -> <i842> base1 ], (i833 = 1) -> <i841> hcomp S1 (loopIt (predZ x) @ (i834 /\ -i841)) [ (i834 = 0) -> <i844> base1, (i834 = 1) -> <i844> loopIt (predZ x) @ (-i841 \/ i844), (i841 = 1) -> <i844> loopIt (predZ x) @ (i834 /\ i844) ], (i834 = 0) -> <i841> base1, (i834 = 1) -> <i841> base1 ]) [ (i834 = 0) -> <i839> base1, (i834 = 1) -> <i839> loop1 {S1} @ i839 ]) [ (i833 = 0) -> <i835> hcomp S1 (hcomp S1 (hcomp S1 (loopIt (predZ x) @ i834) [ (i834 = 0) -> <i838> base1, (i834 = 1) -> <i838> base1 ]) [ (i834 = 0) -> <i837> base1, (i834 = 1) -> <i837> base1 ]) [ (i834 = 0) -> <i836> base1, (i834 = 1) -> <i836> loop1 {S1} @ i836 ], (i833 = 1) -> <i835> shift x @ i835 @ i834, (i834 = 0) -> <i835> base1, (i834 = 1) -> <i835> base1 ]) (s @ i801 @ i830) (transGen (<i831> helix (s @ i801 @ (i830 /\ i831))) 0 (pos zero)) @ i802, (i806 = 1) -> <i830> s @ i801 @ (i802 /\ i830) ], (i801 = 0) -> <i806> hcomp S1 base1 [ (i802 = 0) -> <i853> base1, (i802 = 1) -> <i853> p @ i853, (i806 = 0) -> <i853> s1elim (\(x : S1) -> (helix x) -> (PathP (<i855> S1) base1 x)) loopIt (<i856> \(x : Z) -> <i857> hcomp S1 (hcomp S1 (hcomp S1 (hcomp S1 (hcomp S1 (loopIt (predZ x) @ (-i856 /\ i857)) [ (i856 = 0)(i857 = 1) -> <i872> base1, (i856 = 1) -> <i872> base1, (i857 = 0) -> <i872> base1 ]) [ (i856 = 1) -> <i868> hcomp S1 (loopIt (predZ x) @ (i857 /\ i868)) [ (i857 = 0) -> <i869> base1, (i857 = 1)(i868 = 1) -> <i869> base1, (i868 = 0) -> <i869> base1 ], (i857 = 0) -> <i868> base1, (i857 = 1) -> <i868> hcomp S1 (loopIt (predZ x) @ (-i856 \/ i868)) [ (i856 = 0) -> <i871> base1, (i856 = 1)(i868 = 0) -> <i871> base1, (i868 = 1) -> <i871> base1 ] ]) [ (i856 = 0) -> <i864> hcomp S1 (hcomp S1 (loopIt (predZ x) @ i857) [ (i857 = 0) -> <i866> base1, (i857 = 1) -> <i866> base1 ]) [ (i857 = 0) -> <i865> base1, (i857 = 1) -> <i865> base1 ], (i856 = 1) -> <i864> hcomp S1 (loopIt (predZ x) @ (i857 /\ -i864)) [ (i857 = 0) -> <i867> base1, (i857 = 1) -> <i867> loopIt (predZ x) @ (-i864 \/ i867), (i864 = 1) -> <i867> loopIt (predZ x) @ (i857 /\ i867) ], (i857 = 0) -> <i864> base1, (i857 = 1) -> <i864> base1 ]) [ (i857 = 0) -> <i862> base1, (i857 = 1) -> <i862> loop1 {S1} @ i862 ]) [ (i856 = 0) -> <i858> hcomp S1 (hcomp S1 (hcomp S1 (loopIt (predZ x) @ i857) [ (i857 = 0) -> <i861> base1, (i857 = 1) -> <i861> base1 ]) [ (i857 = 0) -> <i860> base1, (i857 = 1) -> <i860> base1 ]) [ (i857 = 0) -> <i859> base1, (i857 = 1) -> <i859> loop1 {S1} @ i859 ], (i856 = 1) -> <i858> shift x @ i858 @ i857, (i857 = 0) -> <i858> base1, (i857 = 1) -> <i858> base1 ]) (p @ i853) (transGen (<i854> helix (p @ (i853 /\ i854))) 0 (pos zero)) @ i802, (i806 = 1) -> <i853> p @ (i802 /\ i853) ], (i801 = 1) -> <i806> hcomp S1 base1 [ (i802 = 0) -> <i876> base1, (i802 = 1) -> <i876> q @ i876, (i806 = 0) -> <i876> s1elim (\(x : S1) -> (helix x) -> (PathP (<i878> S1) base1 x)) loopIt (<i879> \(x : Z) -> <i880> hcomp S1 (hcomp S1 (hcomp S1 (hcomp S1 (hcomp S1 (loopIt (predZ x) @ (-i879 /\ i880)) [ (i879 = 0)(i880 = 1) -> <i895> base1, (i879 = 1) -> <i895> base1, (i880 = 0) -> <i895> base1 ]) [ (i879 = 1) -> <i891> hcomp S1 (loopIt (predZ x) @ (i880 /\ i891)) [ (i880 = 0) -> <i892> base1, (i880 = 1)(i891 = 1) -> <i892> base1, (i891 = 0) -> <i892> base1 ], (i880 = 0) -> <i891> base1, (i880 = 1) -> <i891> hcomp S1 (loopIt (predZ x) @ (-i879 \/ i891)) [ (i879 = 0) -> <i894> base1, (i879 = 1)(i891 = 0) -> <i894> base1, (i891 = 1) -> <i894> base1 ] ]) [ (i879 = 0) -> <i887> hcomp S1 (hcomp S1 (loopIt (predZ x) @ i880) [ (i880 = 0) -> <i889> base1, (i880 = 1) -> <i889> base1 ]) [ (i880 = 0) -> <i888> base1, (i880 = 1) -> <i888> base1 ], (i879 = 1) -> <i887> hcomp S1 (loopIt (predZ x) @ (i880 /\ -i887)) [ (i880 = 0) -> <i890> base1, (i880 = 1) -> <i890> loopIt (predZ x) @ (-i887 \/ i890), (i887 = 1) -> <i890> loopIt (predZ x) @ (i880 /\ i890) ], (i880 = 0) -> <i887> base1, (i880 = 1) -> <i887> base1 ]) [ (i880 = 0) -> <i885> base1, (i880 = 1) -> <i885> loop1 {S1} @ i885 ]) [ (i879 = 0) -> <i881> hcomp S1 (hcomp S1 (hcomp S1 (loopIt (predZ x) @ i880) [ (i880 = 0) -> <i884> base1, (i880 = 1) -> <i884> base1 ]) [ (i880 = 0) -> <i883> base1, (i880 = 1) -> <i883> base1 ]) [ (i880 = 0) -> <i882> base1, (i880 = 1) -> <i882> loop1 {S1} @ i882 ], (i879 = 1) -> <i881> shift x @ i881 @ i880, (i880 = 0) -> <i881> base1, (i880 = 1) -> <i881> base1 ]) (q @ i876) (transGen (<i877> helix (q @ (i876 /\ i877))) 0 (pos zero)) @ i802, (i806 = 1) -> <i876> q @ (i802 /\ i876) ], (i802 = 0) -> <i806> base1, (i802 = 1) -> <i806> base1 ]
-- Time: 0m0.008s
