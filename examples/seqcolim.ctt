module seqcolim where

import nat
import sigma
import equiv
import susp

--- General lemmas

lemPathPProp (A B : U) (AProp : prop A) (p : Path U A B) : (x : A) -> (y : B) -> PathP p x y
  = J U A (\(B : U) -> \(p : Path U A B) -> (x : A) -> (y : B) -> PathP p x y) AProp B p
opaque lemPathPProp

transRefl (A : U) (a : A) : Path A (transport (<_> A) a) a = <i> comp (<_> A) a [(i=1) -> <_>a]
opaque transRefl

lemReflComp (A : U) (a b : A) (p : Path A a b) : Path (Path A a b) (compPath A a a b (<_> a) p) p =
  <j i> comp (<k> A) (p @ i /\ j) [(i=0) -> <_> a, (j=1) -> <_> p @ i, (i=1) -> <k> p @ k \/ j ]
opaque lemReflComp

lemReflComp' (A : U) (a b : A) (p : Path A a b) : Path (Path A a b) (compPath A a b b p (<_> b)) p =
  <j i> comp (<k> A) (p @ i) [(i=0) -> <_> a, (j=1) -> <_> p @ i, (i=1) -> <_> b ]
opaque lemReflComp'

substPathP (A B : U) (p : Path U A B) (x : A) (y : B) (q : Path B (transport p x) y) : PathP p x y
  = transport (<i> PathP p x (q@i)) hole
  where
    hole : PathP p x (transport p x) = <i> comp (<j> p @ (i /\ j)) x [(i=0) -> <_> x]
opaque substPathP

transportIsoPath (A B : U) (f : A -> B) (g : B -> A)
               (s : (y : B) -> Path B (f (g y)) y)
               (t : (x : A) -> Path A (g (f x)) x)
               (x : A)
               : Path B (transport (isoPath A B f g s t) x) (f x)
               = compPath B (transport (<_> B) (transport (<_> B) (f x))) (transport (<_> B) (f x)) (f x)
                 (<i> transport (<_> B) (transRefl B (f x) @ i)) (transRefl B (f x))
opaque transportIsoPath

transportIsoPath' (A B : U) (f : A -> B) (g : B -> A)
               (s : (y : B) -> Path B (f (g y)) y)
               (t : (x : A) -> Path A (g (f x)) x)
               (x : B)
               : Path A (transport (<i> isoPath A B f g s t @ -i) x) (g x)
               = compPath A (transport (<_> A) (g (transport (<_> B) x))) (transport (<_> A) (g x)) (g x)
                 (<i> transport (<_> A) (g (transRefl B x @ i))) (transRefl A (g x))
opaque transportIsoPath'

isoPathP (A B : U) (f : A -> B) (g : B -> A)
         (s : (y : B) -> Path B (f (g y)) y)
         (t : (x : A) -> Path A (g (f x)) x)
         (x : A)
         : PathP (isoPath A B f g s t) x (f x)
         = substPathP A B (isoPath A B f g s t) x (f x) (transportIsoPath A B f g s t x)
opaque isoPathP


contrSingl' (A : U) (x : A) : isContr ((y : A) * Path A x y)
  = ( (x, <_> x)
    , \(p : (y:A) * Path A x y) -> <i> (p.2@i, <j> p.2@i/\j)
    )

--- Sequences and sequential colimits

-- A coinductive definition could be used instead.
sequence : U = (A:nat->U) * ((n:nat) -> (x:A n) -> A (suc n))
shiftSequence (C:sequence):sequence
 = (\(n:nat) -> C.1 (suc n), \(n:nat) -> C.2 (suc n))

sequenceFib (A : sequence) : U = (P : (n:nat) (a:A.1 n) -> U)
                             * ((n:nat) (a:A.1 n) -> P n a -> P (suc n) (A.2 n a))
shiftSequenceFib (A:sequence) (B:sequenceFib A) : sequenceFib (shiftSequence A)
  = (\(n:nat) -> B.1 (suc n), \(n:nat) -> B.2 (suc n))

-- The usual definition of a sequential colimit
data seqCo0 (C:sequence)
  = inj0 (n:nat) (x:C.1 n)
  | gl0 (n:nat) (x:C.1 n) <i>
    [ (i=0) -> inj0 n x
    , (i=1) -> inj0 (suc n) (C.2 n x)
    ]

-- Alternative definition
data seqCo (C:sequence)
  = inj (a:C.1 zero)
  | lift (x:seqCo (shiftSequence C))
  | gl (a:C.1 zero) <i>
    [ (i=0) -> inj a
    , (i=1) -> lift (inj (C.2 zero a))
    ]

-- Induction principle :
-- P      : (A:sequence) -> seqCo A -> U
-- f_inj  : (x : A.1 zero) -> P A (inj x)
-- f_lift : (x : seqCo (shiftSequence A)) -> P (shiftSequence A) x -> P A (lift x)
-- f_gl   : (x : A.1 zero) -> f_inj x =_{P A (gl x)} f_lift (lift (inj))
-- -------------------------------------------------------------------------------------------------
-- (A:sequence) -> (x:seqCo A) -> P A x

-- lemShift : The colimit of a shifted sequence is equivalent to the colimit.
-- (lift : seqCo (shiftSequence C) -> seqCo C is an equivalence).

lemShiftF (C:sequence) : seqCo C -> seqCo (shiftSequence C) = split
  inj a -> inj (C.2 zero a)
  lift x -> x
  gl a @ i -> inj (C.2 zero a)
lemShiftG (C:sequence) (x:seqCo (shiftSequence C)) : seqCo C = lift x

lemShiftFG (C:sequence) : (x:seqCo C) -> Path (seqCo C) (lemShiftG C (lemShiftF C x)) x = split
  inj a -> <i> gl {seqCo C} a @ -i
  lift x -> <_> lift x
  gl a @ i -> <j> gl {seqCo C} a @ i\/-j
lemShiftGF (C:sequence) (x:seqCo (shiftSequence C)) : Path (seqCo (shiftSequence C)) (lemShiftF C (lemShiftG C x)) x = <_> x

lemShift (C:sequence) : Path U (seqCo C) (seqCo (shiftSequence C)) = isoPath (seqCo C) (seqCo (shiftSequence C)) (lemShiftF C) (lemShiftG C) (lemShiftGF C) (lemShiftFG C)

lemShiftPath1 (C:sequence) : (x:seqCo C) -> PathP (lemShift C) x (lemShiftF C x) = isoPathP (seqCo C) (seqCo (shiftSequence C)) (lemShiftF C) (lemShiftG C) (lemShiftGF C) (lemShiftFG C)
lemShiftPath (C:sequence) (x:seqCo (shiftSequence C)) : PathP (lemShift C) (lift x) x = lemShiftPath1 C (lift x)

lift0 (A:sequence) : seqCo0 (shiftSequence A) -> seqCo0 A = split
  inj0 n x -> inj0 (suc n) x
  gl0 n x @ i -> gl0 {seqCo0 A} (suc n) x @ i


-- Both definitions of a sequential colimit are equivalent.
equivSeqCo (A:sequence) : Path U (seqCo0 A) (seqCo A) = isoPath (seqCo0 A) (seqCo A) (F A) (G A) (GF A) (FG A)
  where
    Fi (A:sequence) : (n:nat) (x:A.1 n) -> seqCo A = split
      zero -> \(x:A.1 zero) -> inj x
      suc n -> \(x:A.1 (suc n)) -> lift (Fi (shiftSequence A) n x)
    Fg (A:sequence) : (n:nat) (x:A.1 n) -> Path (seqCo A) (Fi A n x) (Fi A (suc n) (A.2 n x)) = split
      zero -> \(x:A.1 zero) -> <i> gl {seqCo A} x @ i
      suc n -> \(x:A.1 (suc n)) -> <i> lift (Fg (shiftSequence A) n x @ i)
    F (A:sequence) : seqCo0 A -> seqCo A = split
      inj0 n x -> Fi A n x
      gl0 n x @ i -> Fg A n x @ i
    G (A:sequence) : seqCo A -> seqCo0 A = split
      inj x -> inj0 zero x
      lift x -> lift0 A (G (shiftSequence A) x)
      gl x @ i -> gl0 {seqCo0 A} zero x @ i
    FGi (A:sequence) : (n:nat) (x:A.1 n) -> Path (seqCo0 A) (G A (Fi A n x)) (inj0 n x) = split
      zero  -> \(x:A.1 zero) -> <_> inj0 zero x
      suc n -> \(x:A.1 (suc n)) -> <i> lift0 A (FGi (shiftSequence A) n x @ i)
    FGg (A:sequence) : (n:nat) (x:A.1 n) -> PathP (<i> Path (seqCo0 A) (G A (Fg A n x @ i)) (gl0 {seqCo0 A} n x @ i))
                                                  (FGi A n x)
                                                  (FGi A (suc n) (A.2 n x)) = split
      zero -> \(x:A.1 zero) -> <i> <j> gl0 {seqCo0 A} zero x @ i
      suc n -> \(x:A.1 (suc n)) -> <i> <j> lift0 A (FGg (shiftSequence A) n x @ i @ j)
    FG (A:sequence) : (x:seqCo0 A) -> Path (seqCo0 A) (G A (F A x)) x = split
      inj0 n x -> FGi A n x
      gl0 n x @ i -> FGg A n x @ i
    GFl (A:sequence) : (x:seqCo0 (shiftSequence A)) -> Path (seqCo A) (F A (lift0 A x)) (lift (F (shiftSequence A) x)) = split
      inj0 n x -> <_> F A (inj0 (suc n) x)
      gl0 n x @ i -> <_> F A (gl0 {seqCo0 A} (suc n) x @ i)
    GF (A:sequence) : (x:seqCo A) -> Path (seqCo A) (F A (G A x)) x = split
      inj x    -> <_> inj x
      lift x   -> compPath (seqCo A)
                   (F A (lift0 A (G (shiftSequence A) x)))
                   (lift (F (shiftSequence A) (G (shiftSequence A) x)))
                   (lift x)
                   (GFl A (G (shiftSequence A) x))
                   (<i> lift (GF (shiftSequence A) x @ i))
      gl x @ i -> transport
                  (<l> PathP (<i> Path (seqCo A) (gl {seqCo A} x @ i) (gl {seqCo A} x @ i))
                        (<_> inj x)
                        (lemReflComp (seqCo A) (gl {seqCo A} x @ 1) (gl {seqCo A} x @ 1) (<_> gl {seqCo A} x @ 1) @ -l))
                  (<i> <j> gl {seqCo A} x @ i) @ i

---

code_i (A:sequence) (B:sequenceFib A) (a:A.1 zero) : sequence
  = let next:sequence = code_i (shiftSequence A) (shiftSequenceFib A B) (A.2 zero a)
        f : nat -> U = split
          zero -> B.1 zero a
          suc n -> next.1 n
        g : (n:nat) -> f n -> f (suc n) = split
          zero -> B.2 zero a
          suc n -> next.2 n
    in (f, g)

code_g (A:sequence) (B:sequenceFib A) (a:A.1 zero)
  : Path U (seqCo (code_i A B a))
           (seqCo (code_i (shiftSequence A) (shiftSequenceFib A B) (A.2 zero a)))
  = lemShift (code_i A B a)

code (A:sequence) (B:sequenceFib A) : seqCo A -> U = split
  inj a -> seqCo (code_i A B a)
  lift x -> code (shiftSequence A) (shiftSequenceFib A B) x
  gl a @ i -> code_g A B a @ i

---

sigmaSequence (A:sequence) (B:sequenceFib A) : sequence
  = (\(n:nat) -> Sigma (A.1 n) (B.1 n), \(n:nat) (x : Sigma (A.1 n) (B.1 n)) -> (A.2 n x.1, B.2 n x.1 x.2))

liftCodeEq (A:sequence) (B:sequenceFib A) (x:A.1 zero) (y:B.1 zero x)
  : PathP (<i> code A B (gl {seqCo A} x @ i)) (inj y) (inj (B.2 zero x y))
  = lemShiftPath1 (code_i A B x) (inj y)

-- Proof of the commutation of sigmas and sequential colimits
-- sigmaColimit (A:sequence) (B:sequenceFib A) : Path U (seqCo (sigmaSequence A B)) (Sigma (seqCo A) (code A B))

F (A:sequence) (B:sequenceFib A) : seqCo (sigmaSequence A B) -> Sigma (seqCo A) (code A B) = split
  inj a -> (inj a.1, inj a.2)
  lift x -> let p : Sigma (seqCo (shiftSequence A)) (code (shiftSequence A) (shiftSequenceFib A B))
                  = F (shiftSequence A) (shiftSequenceFib A B) x
            in (lift p.1, p.2)
  gl a @ i -> (gl {seqCo A} a.1 @ i, liftCodeEq A B a.1 a.2 @ i)

G0 (A:sequence) (B:sequenceFib A) : (x:seqCo A) (y:code A B x) -> seqCo (sigmaSequence A B) = split
  inj x -> split@(seqCo (code_i A B x) -> seqCo (sigmaSequence A B)) with
    inj y    -> inj (x,y)
    lift y   -> lift (G0 (shiftSequence A) (shiftSequenceFib A B) (inj (A.2 zero x)) y)
    gl y @ j -> gl {seqCo (sigmaSequence A B)} (x,y) @ j
  lift x -> \(y:code A B (lift x)) -> lift (G0 (shiftSequence A) (shiftSequenceFib A B) x y)
  gl x @ i -> \(y:code A B (gl {seqCo A} x @ i)) ->
                  G0 A B (inj x)
                  (comp (<j> code A B (gl {seqCo A} x @ i /\ -j))
                     y
                     [ (i=0) -> <_> y
                     , (i=1) -> <j> lemShiftPath (code_i A B x) y @ -j
                     ])

G0_g_eq (A:sequence) (B:sequenceFib A) (x:A.1 zero) (y:code A B (lift (inj (A.2 zero x))))
  : Path (Path (seqCo (sigmaSequence A B)) (G0 A B (inj x) (lift y)) (G0 A B (inj x) (lift y)))
         (<i> G0 A B (gl {seqCo A} x @ i) (lemShiftPath (code_i A B x) y @ i))
         (<_> G0 A B (inj x) (lift y))
  = <i> <j> G0 A B (inj x)
                   (comp (<k> code A B (gl {seqCo A} x @ j /\ -k))
                      (lemShiftPath (code_i A B x) y @ j)
                      [ (j=0) -> <_> lemShiftPath (code_i A B x) y @ 0
                      , (j=1) -> <k> lemShiftPath (code_i A B x) y @ -k
                      , (i=1) -> <k> lemShiftPath (code_i A B x) y @ j /\ -k
                      ])

G (A:sequence) (B:sequenceFib A) (x:Sigma (seqCo A) (code A B)) : seqCo (sigmaSequence A B) = G0 A B x.1 x.2

FG (A:sequence) (B:sequenceFib A) : (x:seqCo (sigmaSequence A B)) -> Path (seqCo (sigmaSequence A B)) (G A B (F A B x)) x = split
  inj a    -> <_> inj a
  lift x   -> <i> lift (FG (shiftSequence A) (shiftSequenceFib A B) x @ i)
  gl a @ i -> let ans : PathP (<i> Path (seqCo (sigmaSequence A B))
                                        (G0 A B (inj a.1)
                                         (comp (<j> code A B (gl {seqCo A} a.1 @ i /\ -j))
                                            (lemShiftPath1 (code_i A B a.1) (inj a.2) @ i)
                                            [ (i=0) -> <_> inj a.2
                                            , (i=1) -> <j> lemShiftPath1 (code_i A B a.1) (lift (inj (B.2 zero a.1 a.2))) @ -j
                                            ]))
                                        (gl {seqCo (sigmaSequence A B)} a @ i))
                             (<_> inj a)
                             (<_> lift (inj ((sigmaSequence A B).2 zero a)))
                      = <i> <k> G0 A B (inj a.1)
                              (comp (<j> code A B (gl {seqCo A} a.1 @ i /\ -j /\ -k))
                                 (lemShiftPath1 (code_i A B a.1) (gl {code A B (inj a.1)} a.2 @ k /\ i) @ i /\ -k)
                                 [ (i=0) -> <_> inj a.2
                                 , (i=1) -> <j> comp (<l> code A B (gl {seqCo A} a.1 @ -j /\ -k))
                                                (lemShiftPath1 (code_i A B a.1) (gl {code A B (inj a.1)} a.2 @ k) @ -j /\ -k)
                                                [ (k=1) -> <_> gl {code A B (inj a.1)} a.2 @ 1
                                                , (j=0) -> <_> lemShiftPath1 (code_i A B a.1) (gl {code A B (inj a.1)} a.2 @ k) @ -k
                                                , (k=0) -> <l> lemShiftPath1 (code_i A B a.1) (gl {code A B (inj a.1)} a.2 @ l) @ -j
                                                , (j=1) -> <l> gl {code A B (inj a.1)} a.2 @ k \/ l
                                                ]
                                 , (k=1) -> <_> gl {code A B (inj a.1)} a.2 @ i
                                 ])
              in ans @ i

GF0 (A:sequence) (B:sequenceFib A) : (x:seqCo A) (y:code A B x)
                                 -> Path (Sigma (seqCo A) (code A B)) (F A B (G0 A B x y)) (x,y) = split
  inj x    -> split@((y:seqCo (code_i A B x)) -> Path (Sigma (seqCo A) (code A B)) (F A B (G0 A B (inj x) y)) (inj x, y)) with
    inj y    -> <_> (inj x, inj y)
    lift y   -> let p : Path (Sigma (seqCo (shiftSequence A)) (code (shiftSequence A) (shiftSequenceFib A B)))
                             (F (shiftSequence A) (shiftSequenceFib A B) (G0 (shiftSequence A) (shiftSequenceFib A B) (inj (A.2 zero x)) y))
                             (inj (A.2 zero x), y)
                      = GF0 (shiftSequence A) (shiftSequenceFib A B) (inj (A.2 zero x)) y
                in compPath (Sigma (seqCo A) (code A B))
                       (lift (p@0).1, (p@0).2)
                       (lift (inj (A.2 zero x)), y)
                       (inj x, lift y)
                       (<i> (lift (p@i).1, (p@i).2))
                       (<i> (gl {seqCo A} x @ -i, lemShiftPath (code_i A B x) y @ -i))
    gl y @ j -> let q0 : PathP
                          (<i> Path (Sigma (seqCo A) (code A B))
                                    (gl {seqCo A} x @ i, lemShiftPath1 (code_i A B x) (inj y) @ i)
                                    (inj x, gl {code A B (inj x)} y @ i))
                          (<_> (inj x, inj y))
                          (<j> (gl {seqCo A} x @ -j, lemShiftPath1 (code_i A B x) (lift (inj (B.2 zero x y))) @ -j))
                      = <i j> ( gl {seqCo A} x @ i /\ -j
                              , comp (<k> code A B (gl {seqCo A} x @ i /\ -j))
                                (lemShiftPath1 (code_i A B x) (gl {code A B (inj x)} y @ i /\ j) @ i /\ -j)
                                [ (j=0) -> <_> lemShiftPath1 (code_i A B x) (inj y) @ i
                                , (j=1) -> <_> gl {code A B (inj x)} y @ i
                                , (i=0) -> <_> inj y
                                , (i=1) -> <k> lemShiftPath1 (code_i A B x) (gl {code A B (inj x)} y @ j \/ k) @ -j
                                ])
                    q : PathP
                        (<i> Path (Sigma (seqCo A) (code A B))
                                  (F A B (gl {seqCo (sigmaSequence A B)} (x,y) @ i))
                                  (inj x, gl {code A B (inj x)} y @ i))
                        (GF0 A B (inj x) (inj y))
                        (GF0 A B (inj x) (lift (inj (B.2 zero x y))))
                      = transport
                        (<l> PathP
                             (<i> Path (Sigma (seqCo A) (code A B))
                                       (F A B (gl {seqCo (sigmaSequence A B)} (x,y) @ i))
                                       (inj x, gl {code A B (inj x)} y @ i))
                             (<_> (inj x, inj y))
                             (lemReflComp (Sigma (seqCo A) (code A B))
                               (lift (inj (A.2 zero x)), (inj (B.2 zero x y)))
                               (inj x, lift (inj (B.2 zero x y)))
                               (<i> (gl {seqCo A} x @ -i, lemShiftPath (code_i A B x) (inj (B.2 zero x y)) @ -i)) @ -l))
                        q0
                    opaque q
                in q @ j
  lift x   -> \(y:code A B (lift x)) -> <i> (lift (GF0 (shiftSequence A) (shiftSequenceFib A B) x y @ i).1, (GF0 (shiftSequence A) (shiftSequenceFib A B) x y @ i).2)
  gl x @ i -> let p (y:code A B (lift (inj (A.2 zero x))))
                    : Path (Sigma (seqCo (shiftSequence A)) (code (shiftSequence A) (shiftSequenceFib A B)))
                           (F (shiftSequence A) (shiftSequenceFib A B) (G0 (shiftSequence A) (shiftSequenceFib A B) (inj (A.2 zero x)) y))
                           (inj (A.2 zero x), y)
                    = GF0 (shiftSequence A) (shiftSequenceFib A B) (inj (A.2 zero x)) y
                  ans0 : PathP (<i> (y:code A B (gl {seqCo A} x @ i)) ->
                                     Path (Sigma (seqCo A) (code A B))
                                          (F A B (G0 A B (inj x) (comp (<j> code A B (gl {seqCo A} x @ i /\ -j))
                                                                       y
                                                                       [ (i=0) -> <_> y
                                                                       , (i=1) -> <j> lemShiftPath (code_i A B x) y @ -j
                                                                       ])))
                                          (inj x, (comp (<j> code A B (gl {seqCo A} x @ i /\ -j))
                                                        y
                                                        [ (i=0) -> <_> y
                                                        , (i=1) -> <j> lemShiftPath (code_i A B x) y @ -j
                                                        ])))
                              (GF0 A B (inj x))
                              (\(y:code A B (lift (inj (A.2 zero x)))) ->
                                  <i> comp (<_> Sigma (seqCo A) (code A B))
                                           (lift (p y@i).1, (p y@i).2)
                                           [ (i=0) -> <_> (lift (p y@0).1, (p y@0).2)
                                           , (i=1) -> <j> (gl {seqCo A} x @ -j, lemShiftPath (code_i A B x) y @ -j)
                                           ])
                      = <i> \(y:code A B (gl {seqCo A} x @ i)) ->
                                GF0 A B (inj x)
                                (comp (<j> code A B (gl {seqCo A} x @ i /\ -j))
                                   y
                                   [ (i=0) -> <_> y
                                   , (i=1) -> <j> lemShiftPath (code_i A B x) y @ -j
                                   ])
                  opaque ans0
                  ans : PathP (<i> (y:code A B (gl {seqCo A} x @ i)) ->
                                     Path (Sigma (seqCo A) (code A B))
                                          (F A B (G0 A B (gl {seqCo A} x @ i) y))
                                          (gl {seqCo A} x @ i, y))
                              (GF0 A B (inj x))
                              (\(y:code A B (lift (inj (A.2 zero x)))) ->
                                  <i> (lift (p y @ i).1, (p y @ i).2))
                      = transport
                          (<l> PathP (<i> (y:code A B (gl {seqCo A} x @ i)) ->
                                           Path (Sigma (seqCo A) (code A B))
                                                (F A B (G0 A B (gl {seqCo A} x @ i /\ l)
                                                   (comp (<j> code A B (gl {seqCo A} x @ i /\ (-j \/ l)))
                                                          y
                                                          [ (i=0) -> <_> y
                                                          , (i=1) -> <j> lemShiftPath (code_i A B x) y @ -j \/ l
                                                          , (l=1) -> <_> y
                                                          ])))
                                                (gl {seqCo A} x @ i /\ l,
                                                  (comp (<j> code A B (gl {seqCo A} x @ i /\ (-j \/ l)))
                                                        y
                                                        [ (i=0) -> <_> y
                                                        , (i=1) -> <j> lemShiftPath (code_i A B x) y @ -j \/ l
                                                        , (l=1) -> <_> y
                                                        ])))
                                    (GF0 A B (inj x))
                                    (\(y:code A B (lift (inj (A.2 zero x)))) ->
                                        <i> comp (<_> Sigma (seqCo A) (code A B))
                                                 (lift (p y@i).1, (p y@i).2)
                                                 [ (i=0) -> <j> F A B (G0_g_eq A B x y @ -j @ l)
                                                 , (i=1) -> <j> (gl {seqCo A} x @ -j \/ l, lemShiftPath (code_i A B x) y @ -j \/ l)
                                                 , (l=1) -> <_> (lift (p y@i).1, (p y@i).2)
                                                 ])
                          )
                          ans0
                  opaque ans
              in ans @ i

GF (A:sequence) (B:sequenceFib A) (x:Sigma (seqCo A) (code A B)) : Path (Sigma (seqCo A) (code A B)) (F A B (G A B x)) x = GF0 A B x.1 x.2

sigmaColimit (A:sequence) (B:sequenceFib A) : Path U (seqCo (sigmaSequence A B)) (Sigma (seqCo A) (code A B))
  = isoPath (seqCo (sigmaSequence A B)) (Sigma (seqCo A) (code A B)) (F A B) (G A B) (GF A B) (FG A B)

---

-- The colimit of a sequence of contractible types is contractible.
colimitContr (A:sequence) (p:(n:nat) -> isContr (A.1 n)) : isContr (seqCo A) = (inj (p zero).1, f A p (p zero).1)
  where
    f (A:sequence) (p:(n:nat) -> isContr (A.1 n)) (x:A.1 zero) : (y:seqCo A) -> Path (seqCo A) (inj x) y = split
      inj y    -> <i> inj (isContrProp (A.1 zero) (p zero) x y @ i)
      lift y   -> compPath (seqCo A)
                           (inj x) (lift (inj (A.2 zero x))) (lift y)
                           (<i> gl {seqCo A} x @ i)
                           (<i> lift (f (shiftSequence A) (\(n:nat) -> p (suc n)) (A.2 zero x) y @ i))
      gl y @ i -> let hole : Path (Path (seqCo A) (inj x) (lift (inj (A.2 zero x))))
                               (<i> gl {seqCo A} x @ i)
                               (compPath (seqCo A)
                                 (inj x) (lift (inj (A.2 zero x))) (lift (inj (A.2 zero x)))
                                 (<i> gl {seqCo A} x @ i)
                                 (<i> lift (inj (isContrProp (A.1 (suc zero)) (p (suc zero)) (A.2 zero x) (A.2 zero x) @ i))))
                           = compPath (Path (seqCo A) (inj x) (lift (inj (A.2 zero x))))
                               (<i> gl {seqCo A} x @ i)
                               (compPath (seqCo A)
                                 (inj x) (lift (inj (A.2 zero x))) (lift (inj (A.2 zero x)))
                                 (<i> gl {seqCo A} x @ i)
                                 (<_> lift (inj (A.2 zero x))))
                               (compPath (seqCo A)
                                 (inj x) (lift (inj (A.2 zero x))) (lift (inj (A.2 zero x)))
                                 (<i> gl {seqCo A} x @ i)
                                 (<i> lift (inj (isContrProp (A.1 (suc zero)) (p (suc zero)) (A.2 zero x) (A.2 zero x) @ i))))
                               (<l> lemReflComp' (seqCo A) (inj x) (lift (inj (A.2 zero x))) (<i> gl {seqCo A} x @ i) @ -l)
                               (<l> compPath (seqCo A)
                                    (inj x) (lift (inj (A.2 zero x))) (lift (inj (A.2 zero x)))
                                    (<i> gl {seqCo A} x @ i)
                                    (<i> lift (inj (propSet (A.1 (suc zero)) (isContrProp (A.1 (suc zero)) (p (suc zero)))
                                                            (A.2 zero x) (A.2 zero x)
                                                            (<_> A.2 zero x)
                                                            (<i> isContrProp (A.1 (suc zero)) (p (suc zero)) (A.2 zero x) (A.2 zero x) @ i)
                                                            @ l @ i))))
                      ans : PathP (<i> Path (seqCo A) (inj x) (gl {seqCo A} y @ i))
                              (<i> inj (isContrProp (A.1 zero) (p zero) x y @ i))
                              (compPath (seqCo A)
                                (inj x)
                                (lift (inj (A.2 zero x)))
                                (lift (inj (A.2 zero y)))
                                (<i> gl {seqCo A} x @ i)
                                (<i> lift (inj (isContrProp (A.1 (suc zero)) (p (suc zero)) (A.2 zero x) (A.2 zero y) @ i))))
                          = J (A.1 zero) x
                              (\(y:A.1 zero)(q:Path (A.1 zero) x y)->
                                  PathP (<i> Path (seqCo A) (inj x) (gl {seqCo A} y @ i))
                                    (<i> inj (q@i))
                                    (compPath (seqCo A)
                                      (inj x)
                                      (lift (inj (A.2 zero x)))
                                      (lift (inj (A.2 zero y)))
                                      (<i> gl {seqCo A} x @ i)
                                      (<i> lift (inj (isContrProp (A.1 (suc zero)) (p (suc zero)) (A.2 zero x) (A.2 zero y) @ i)))))
                              (transport
                                (<l> PathP (<i> Path (seqCo A) (inj x) (gl {seqCo A} x @ i))
                                       (<i> inj x) (hole@l))
                                (<i j> gl {seqCo A} x @ i/\j)
                              )
                              y (isContrProp (A.1 zero) (p zero) x y)
                  in ans @ i

-- The sequence fibration   (\y -> x = y) ---> (\y -> \uparrow x = y) ---> ...
ySSeq (A:sequence) (x:A.1 zero) : sequenceFib A =
  let p : sequenceFib (shiftSequence A) = ySSeq (shiftSequence A) (A.2 zero x)
      f : (n:nat) -> A.1 n -> U = split
        zero -> \(y:A.1 zero) -> Path (A.1 zero) x y
        suc n -> p.1 n
      g : (n:nat) -> (a:A.1 n) -> f n a -> f (suc n) (A.2 n a) = split
        zero -> \(y:A.1 zero) (p:Path (A.1 zero) x y) -> <i> A.2 zero (p@i)
        suc n -> p.2 n
  in (f,g)

sigmaYContr (A:sequence) (x:A.1 zero) : isContr (seqCo (sigmaSequence A (ySSeq A x))) = colimitContr (sigmaSequence A (ySSeq A x)) (prf A x)
  where prf (A:sequence) (x:A.1 zero) : (n:nat) -> isContr ((sigmaSequence A (ySSeq A x)).1 n) = split
          zero  -> contrSingl' (A.1 zero) x
          suc n -> prf (shiftSequence A) (A.2 zero x) n
sigmaCodeContr (A:sequence) (x:A.1 zero) : isContr (Sigma (seqCo A) (code A (ySSeq A x))) = transport (<i> isContr (sigmaColimit A (ySSeq A x) @ i)) (sigmaYContr A x)

-- Theorem 4.7.7 from the HoTT book
lem31192 (A : U) (P : A -> U) (aC : isContr A) : Path U (Sigma A P) (P aC.1) =
  isoPath (Sigma A P) (P aC.1) F G FG GF
  where
    F (a : Sigma A P) : P aC.1 = transport (<i> P ((aC.2 a.1) @ -i)) a.2
    G (a : P aC.1) : Sigma A P = (aC.1, a)
    FG (a : P aC.1) : Path (P aC.1) (transport (<i> P ((aC.2 aC.1) @ -i)) a) a = hole
      where
        prf : Path (Path A aC.1 aC.1) (aC.2 aC.1) (<_> aC.1) = propSet A (isContrProp A aC) aC.1 aC.1 (aC.2 aC.1) (<_> aC.1)
        hole1 : Path (P aC.1) (transport (<_> P aC.1) a) a = transRefl (P aC.1) a
        hole : Path (P aC.1) (transport (<i> P ((aC.2 aC.1) @ -i)) a) a
          = transport (<i> Path (P aC.1) (transport (<j> P ((prf @ -i) @ -j)) a) a) hole1
    GF (a : Sigma A P) : Path (Sigma A P) (aC.1, transport (<i> P ((aC.2 a.1) @ -i)) a.2) a = hole
      where
        hole2 : Path A aC.1 a.1 = aC.2 a.1
        hole1 : PathP (<i> P (hole2 @ i)) (transport (<i> P ((aC.2 a.1) @ -i)) a.2) a.2
              = <i> comp (<j> P (hole2 @ i \/ -j)) a.2 [(i=1) -> <_> a.2]
        hole : Path (Sigma A P) (aC.1, transport (<i> P ((aC.2 a.1) @ -i)) a.2) a
             = transport (<i> (lemPathSig A P (aC.1, transport (<i> P ((aC.2 a.1) @ -i)) a.2) a) @ -i) (hole2, hole1)

total (A : U) (P Q : A -> U) (f : (x : A) -> P x -> Q x) (a : (x : A) * P x) : (x : A) * Q x = (a.1, f a.1 a.2)

ex210 (A : U) (B : A -> U) (C : (x : A) -> B x -> U) : Path U ((x : A) * (y : B x) * C x y) ((x : Sigma A B) * C x.1 x.2)
  = isoPath ((x : A) * (y : B x) * C x y) ((x : Sigma A B) * C x.1 x.2) F G FG GF
  where
    F (a : (x : A) * (y : B x) * C x y) : ((x : Sigma A B) * C x.1 x.2) = ((a.1, a.2.1), a.2.2)
    G (a : (x : Sigma A B) * C x.1 x.2) : ((x : A) * (y : B x) * C x y) = (a.1.1, (a.1.2, a.2))
    FG (a : (x : Sigma A B) * C x.1 x.2) : Path ((x : Sigma A B) * C x.1 x.2) (F (G a)) a = <_> a
    GF (a : (x : A) * (y : B x) * C x y) : Path ((x : A) * (y : B x) * C x y) (G (F a)) a = <_> a

cSigma (A : U) (B : U) (C : A -> B -> U) : Path U ((x : A) * (y : B) * C x y) ((y : B) * (x : A) * C x y) =
  isoPath ((x : A) * (y : B) * C x y) ((y : B) * (x : A) * C x y)
  (\(a : (x : A) * (y : B) * C x y) -> (a.2.1, (a.1, a.2.2)))
  (\(a : (y : B) * (x : A) * C x y) -> (a.2.1, (a.1, a.2.2)))
  (\(a : (y : B) * (x : A) * C x y) -> <_> a)
  (\(a : (x : A) * (y : B) * C x y) -> <_> a)

th476 (A : U) (P Q : A -> U) (f : (x : A) -> P x -> Q x) (x : A) (v : Q x)
  : Path U (fiber (Sigma A P) (Sigma A Q) (total A P Q f) (x, v)) (fiber (P x) (Q x) (f x) v)
  = hole
  where
    A1 : U = (w : Sigma A P) * Path (Sigma A Q) (x, v) (total A P Q f w)
    A2 : U = (a : A) * (u : P a) * Path (Sigma A Q) (x, v) (a, f a u)
    A3 : U = (a : A) * (u : P a) * (p : Path A x a) * PathP (<i> Q (p @ i)) v (f a u)
    A4 : U = (a : A) * (p : Path A x a) * (u : P a) * PathP (<i> Q (p @ i)) v (f a u)
    A5 : U = (w : (a : A) * Path A x a) * (u : P w.1) * PathP (<i> Q (w.2 @ i)) v (f w.1 u)
    A6 : U = (u : P x) * Path (Q x) v (f x u)
    E12 : Path U A1 A2 = <i> (ex210 A P (\(a : A) -> \(b : P a) -> Path (Sigma A Q) (x, v) (a, f a b))) @ -i
    E23 : Path U A2 A3 = <i> (a : A) * (u : P a) * (lemPathSig A Q (x, v) (a, f a u)) @ i
    E34 : Path U A3 A4 = <i> (a : A) * (cSigma (P a) (Path A x a) (\(u : P a) -> \(p : Path A x a) -> PathP (<j> Q (p @ j)) v (f a u))) @ i
    E45 : Path U A4 A5 = ex210 A (Path A x) (\(a : A) -> \(p : Path A x a) -> (u : P a) * PathP (<i> Q (p @ i)) v (f a u))
    E56 : Path U A5 A6 = lem31192 ((a : A) * Path A x a) (\(w : (a : A) * Path A x a) -> (u : P w.1) * PathP (<i> Q (w.2 @ i)) v (f w.1 u))
                       (contrSingl' A x)
    hole : Path U A1 A6 = compPath U A1 A2 A6 E12 (compPath U A2 A3 A6 E23 (compPath U A3 A4 A6 E34 (compPath U A4 A5 A6 E45 E56)))

isoPathProp (A B : U) (AProp : prop A) (BProp : prop B) (F : A -> B) (G : B -> A) : Path U A B =
  isoPath A B F G (\(y : B) -> BProp (F (G y)) y) (\(x : A) -> AProp (G (F x)) x)

thm477 (A : U) (P Q : A -> U) (f : (x : A) -> P x -> Q x)
  : Path U ((x : A) -> isEquiv (P x) (Q x) (f x)) (isEquiv ((x : A) * P x) ((x : A) * Q x) (total A P Q f))
  = hole
  where
    AProp : prop ((x : A) -> isEquiv (P x) (Q x) (f x))
          = propPi A (\(x : A) -> isEquiv (P x) (Q x) (f x)) (\(x : A) -> propIsEquiv (P x) (Q x) (f x))
    BProp : prop (isEquiv ((x : A) * P x) ((x : A) * Q x) (total A P Q f)) = propIsEquiv ((x : A) * P x) ((x : A) * Q x) (total A P Q f)
    F (a : (x : A) -> isEquiv (P x) (Q x) (f x)) (y : (x : A) * Q x) : isContr (fiber (Sigma A P) (Sigma A Q) (total A P Q f) y)
      = transport (<i> isContr (th476 A P Q f y.1 y.2 @ -i)) (a y.1 y.2)
    G (a : isEquiv ((x : A) * P x) ((x : A) * Q x) (total A P Q f)) (x : A) (y : Q x) : isContr (fiber (P x) (Q x) (f x) y)
      = transport (<i> isContr (th476 A P Q f x y @ i)) (a (x, y))
    hole : Path U ((x : A) -> isEquiv (P x) (Q x) (f x)) (isEquiv ((x : A) * P x) ((x : A) * Q x) (total A P Q f))
      = isoPathProp ((x : A) -> isEquiv (P x) (Q x) (f x)) (isEquiv ((x : A) * P x) ((x : A) * Q x) (total A P Q f)) AProp BProp F G

--

equivBetweenProp (A B : U) (AProp : prop A) (BProp : prop B) (F : A -> B) (G : B -> A) : isEquiv A B F
  = gradLemma A B F G (\(y : B) -> BProp (F (G y)) y) (\(x : A) -> AProp (G (F x)) x)
isContrProp (A : U) (p : isContr A) (x y : A) : Path A x y = compPath A x p.1 y (<i> p.2 x @ -i) (p.2 y)
equivBetweenContr (A B : U) (cA : isContr A) (cB : isContr B) (f:A->B) : isEquiv A B f
  = equivBetweenProp A B (isContrProp A cA) (isContrProp B cB) f (\(x:B)->cA.1)

equivFiberwiseContr (X:U) (P Q:X->U) (cP:isContr (Sigma X P)) (cQ:isContr (Sigma X Q)) (f:(x:X)->P x->Q x) : (x:X) -> isEquiv (P x) (Q x) (f x)
  = transport (<i> thm477 X P Q f @ -i) (equivBetweenContr (Sigma X P) (Sigma X Q) cP cQ (total X P Q f))

colimitPathsF (A:sequence) (x:A.1 zero) : (y:seqCo A) -> Path (seqCo A) (inj x) y -> code A (ySSeq A x) y
  = J (seqCo A) (inj x) (\(y:seqCo A)(p:Path (seqCo A) (inj x) y) -> code A (ySSeq A x) y)
    (inj (<_> x))

-- A path in a colimit is a colimit of paths.
colimitPaths (A:sequence) (x:A.1 zero) (y:seqCo A) : Path U (Path (seqCo A) (inj x) y) (code A (ySSeq A x) y)
  = equivPath (Path (seqCo A) (inj x) y) (code A (ySSeq A x) y)
              (colimitPathsF A x y)
              (equivFiberwiseContr (seqCo A) (Path (seqCo A) (inj x)) (code A (ySSeq A x)) (contrSingl' (seqCo A) (inj x)) (sigmaCodeContr A x) (colimitPathsF A x) y)
opaque colimitPaths

-- h-levels
hasLevel : (n : nat) -> (A : U) -> U = split
  zero  -> \(A:U) -> prop A
  suc n -> \(A:U) -> (x y : A) -> hasLevel n (Path A x y)

propHasLevel : (n:nat) (A:U) -> prop (hasLevel n A) = split
  zero -> \(A:U) -> propIsProp A
  suc n -> \(A:U) -> propPi A (\(x:A)->(y:A)->hasLevel n (Path A x y))
          (\(x:A) -> propPi A (\(y:A)->hasLevel n (Path A x y))
          (\(y:A) -> propHasLevel n (Path A x y)))

hasLevelSuc : (n:nat) -> (A:U) -> hasLevel n A -> hasLevel (suc n) A = split
  zero -> propSet
  suc n -> \(A:U)(l:hasLevel (suc n) A)(x y:A)->hasLevelSuc n (Path A x y) (l x y)

hasLevelSequence (l:nat) (C:sequence) : U = (m:nat) -> hasLevel l (C.1 m)

wconst (A B:U) (f:A->B) : U = (x y : A) -> Path B (f x) (f y)
wpconst : (n:nat) (A B:U) (f:A->B) -> U = split
  zero -> wconst
  suc n -> \(A B:U)(f:A->B) -> (x y : A) -> wpconst n (Path A x y) (Path B (f x) (f y)) (mapOnPath A B f x y)

wconstAp (A B:U) (f:A->B) (w:wconst A B f) (x y:A) : wconst (Path A x y) (Path B (f x) (f y)) (mapOnPath A B f x y)
  = \(p q : Path A x y) -> compPath (Path B (f x) (f y)) (<i> f (p@i)) (compPath B (f x) (f y) (f y) (w x y) (<j> w y y @ -j)) (<i> f (q@i)) (g p) (<i> g q @ -i)
  where g (p:Path A x y) : Path (Path B (f x) (f y)) (<i> f (p@i)) (compPath B (f x) (f y) (f y) (w x y) (<j> w y y @ -j))
          = J A x (\(y:A)(p:Path A x y)->Path (Path B (f x) (f y)) (<i> f (p@i)) (compPath B (f x) (f y) (f y) (w x y) (<j> w y y @ -j)))
              (<i> lemInv B (f x) (f x) (<i>w x x@-i) @ -i)
              y p
wconstApRefl (A B:U) (f:A->B) (w:wconst A B f) (x:A) (p:Path A x x) : Path (Path B (f x) (f x)) (<i> f (p@i)) (<_> f x) = wconstAp A B f w x x p (<_> x)

wpconst2 (n:nat) (A B:U) (f:A->B) : U
  = (g : sphere n -> A) -> (h:B) * ((x:sphere n) -> Path B h (f (g x)))

wpconstEq (A B:U) (f:A->B) : (n:nat) -> equiv (wpconst n A B f) (wpconst2 n A B f) = undefined

wconstSequence (C:sequence) : U = (n:nat) -> wconst (C.1 n) (C.1 (suc n)) (C.2 n)
wpconstSequence (m:nat) (C:sequence) : U = (n:nat) -> wpconst m (C.1 n) (C.1 (suc n)) (C.2 n)

---

opaque propIsContr

wconstSeqCoProp0 (C:sequence) (p:wconstSequence C) : seqCo C -> isContr (seqCo C) = split
  inj x    -> let lem (C:sequence) (p:wconstSequence C) (x:C.1 zero)
                      : (y:seqCo C) -> code C (ySSeq C x) y = split
                    inj y    -> lift (inj (p zero x y))
                    lift y   -> lem (shiftSequence C) (\(n:nat) -> p (suc n)) (C.2 zero x) y
                    gl y @ i -> let ans1 : Path (code (shiftSequence C) (ySSeq (shiftSequence C) (C.2 zero x)) (inj (C.2 zero x)))
                                             (inj (<_> C.2 zero x))
                                             (lift (inj (p n1 (C.2 zero x) (C.2 zero x))))
                                         = compPath (code (shiftSequence C) (ySSeq (shiftSequence C) (C.2 zero x)) (inj (C.2 zero x)))
                                             (inj (<_> C.2 zero x))
                                             (lift (inj (<_> C.2 n1 (C.2 zero x))))
                                             (lift (inj (p n1 (C.2 zero x) (C.2 zero x))))
                                             (<i> gl {code (shiftSequence C) (ySSeq (shiftSequence C) (C.2 zero x)) (inj (C.2 zero x))} (<_> C.2 zero x) @ i)
                                          (compPath (code (shiftSequence C) (ySSeq (shiftSequence C) (C.2 zero x)) (inj (C.2 zero x)))
                                             (lift (inj (<_> C.2 n1 (C.2 zero x))))
                                             (lift (lift (inj (<_> C.2 n2 (C.2 n1 (C.2 zero x))))))
                                             (lift (inj (p n1 (C.2 zero x) (C.2 zero x))))
                                             (<i> lift (gl {code (shiftSequence (shiftSequence C)) (ySSeq (shiftSequence (shiftSequence C)) (C.2 n1 (C.2 zero x))) (inj (C.2 n1 (C.2 zero x)))} (<_> C.2 n1 (C.2 zero x)) @ i))
                                          (compPath (code (shiftSequence C) (ySSeq (shiftSequence C) (C.2 zero x)) (inj (C.2 zero x)))
                                             (lift (lift (inj (<_> C.2 n2 (C.2 n1 (C.2 zero x))))))
                                             (lift (lift (inj (<i> C.2 n2 (p n1 (C.2 zero x) (C.2 zero x) @ i)))))
                                             (lift (inj (p n1 (C.2 zero x) (C.2 zero x))))
                                             (<i> lift (lift (inj (<j> wconstApRefl (C.1 n2) (C.1 n3) (C.2 n2) (p n2) (C.2 n1 (C.2 zero x)) (<i> p n1 (C.2 zero x) (C.2 zero x) @ i) @ -i @ j))))
                                             (<i> lift (gl {code (shiftSequence (shiftSequence C)) (ySSeq (shiftSequence (shiftSequence C)) (C.2 n1 (C.2 zero x))) (inj (C.2 n1 (C.2 zero x)))} (p n1 (C.2 zero x) (C.2 zero x)) @ -i))))
                                    ans0 : Path (code C (ySSeq C x) (inj y))
                                             (lift (inj (p zero x y)))
                                             (lift (lift (inj (p n1 (C.2 zero x) (C.2 zero y)))))
                                       = <i> lift (J (C.1 n1) (C.2 zero x)
                                                     (\(y:C.1 n1)(q:Path (C.1 n1) (C.2 zero x) y) ->
                                                        Path (code (shiftSequence C) (ySSeq (shiftSequence C) (C.2 zero x)) (inj y))
                                                         (inj q)
                                                         (lift (inj (p n1 (C.2 zero x) y))))
                                                     ans1
                                                     (C.2 zero y) (p zero x y)
                                                     @ i)
                                    ans : PathP (<i> code C (ySSeq C x) (gl {seqCo C} y @ i))
                                            (lift (inj (p zero x y)))
                                            (lift (inj (p n1 (C.2 zero x) (C.2 zero y))))
                                       = <i> comp (<j> code C (ySSeq C x) (gl {seqCo C} y @ i /\ j))
                                                  (ans0@i)
                                                  [(i=0) -> <_> ans0 @ i
                                                  ,(i=1) -> <j> lemShiftPath (code_i C (ySSeq C x) y) (lift (inj (p n1 (C.2 zero x) (C.2 zero y)))) @ j
                                                  ]
                                in ans @ i
              in (inj x, \(y:seqCo C) -> transport (<i> colimitPaths C x y @ -i) (lem C p x y))
  lift x   -> transport (<i> isContr (lemShift C @ -i)) (wconstSeqCoProp0 (shiftSequence C) (\(n:nat) -> p (suc n)) x)
  gl x @ i -> propIsContr (seqCo C) (wconstSeqCoProp0 C p (inj x)) (wconstSeqCoProp0 C p (lift (inj (C.2 zero x)))) @ i

wpconstSeqCoLevel : (l:nat) -> (C:sequence) (_:wpconstSequence l C) -> hasLevel l (seqCo C) = split
  zero  -> \(C:sequence)(p:wconstSequence C)(x y:seqCo C) -> isContrProp (seqCo C) (wconstSeqCoProp0 C p x) x y
  suc l -> \(C:sequence) (p:wpconstSequence (suc l) C) -> split@((x:seqCo C) -> (y:seqCo C) -> hasLevel l (Path (seqCo C) x y)) with
           inj x    -> let ans (C:sequence) (p:wpconstSequence (suc l) C) (x:C.1 zero) : (y:seqCo C) -> hasLevel l (code C (ySSeq C x) y) = split
                               inj y    -> let ans0 (C:sequence) (p:wpconstSequence (suc l) C) (x y : C.1 zero) : wpconstSequence l (code_i C (ySSeq C x) y) = split
                                                 zero  -> p zero x y
                                                 suc n -> ans0 (shiftSequence C) (\(n:nat) -> p (suc n)) (C.2 zero x) (C.2 zero y) n
                                           in wpconstSeqCoLevel l (code_i C (ySSeq C x) y) (ans0 C p x y)
                               lift y   -> ans (shiftSequence C) (\(n:nat) -> p (suc n)) (C.2 zero x) y
                               gl y @ i -> lemPathPProp
                                              (hasLevel l (code C (ySSeq C x) (inj y)))
                                              (hasLevel l (code C (ySSeq C x) (gl {seqCo C} y @ 1)))
                                              (propHasLevel l (code C (ySSeq C x) (inj y)))
                                              (<i> hasLevel l (code C (ySSeq C x) (gl {seqCo C} y @ i)))
                                              (ans C p x (inj y))
                                              (ans C p x (lift (inj (C.2 zero y))))
                                              @ i
                       in transport (<i> (y:seqCo C) -> hasLevel l (colimitPaths C x y @ -i)) (ans C p x)
           lift x   -> transport (<i> (y:lemShift C @ -i) -> hasLevel l (Path (lemShift C @ -i) (lemShiftPath C x @ -i) y)) (wpconstSeqCoLevel (suc l) (shiftSequence C) (\(n:nat) -> p (suc n)) x)
           gl x @ i -> lemPathPProp
                         ((y:seqCo C) -> hasLevel l (Path (seqCo C) (gl {seqCo C} x @ 0) y))
                         ((y:seqCo C) -> hasLevel l (Path (seqCo C) (gl {seqCo C} x @ 1) y))
                         (propPi (seqCo C) (\(y:seqCo C) -> hasLevel l (Path (seqCo C) (gl {seqCo C} x @ 0) y))
                          (\(y:seqCo C) -> propHasLevel l (Path (seqCo C) (inj x) y)))
                         (<i> (y:seqCo C) -> hasLevel l (Path (seqCo C) (gl {seqCo C} x @ i) y))
                         (wpconstSeqCoLevel (suc l) C p (inj x))
                         (wpconstSeqCoLevel (suc l) C p (lift (inj (C.2 zero x))))
                         @ i

---
