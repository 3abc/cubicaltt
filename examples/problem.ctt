module brunerie3 where

Path (A : U) (a0 a1 : A) : U = PathP (<i> A) a0 a1

compPath (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c =
  <i> hcomp A (p @ i) [ (i =0) -> <j> a, (i = 1) -> q ]

data bool = false | true
data nat = zero | suc (n : nat)

idfun (A : U) (a : A) : A = a

pred : nat -> nat = split
  zero -> zero
  suc n -> n

{- Z is represented as:

  +2 = pos (suc (suc zero))
  +1 = pos (suc zero)
   0 = pos zero
  -1 = neg zero
  -2 = neg (suc zero)

-}
data Z = pos (n : nat) | neg (n : nat)

twoZ : Z = pos (suc (suc zero))
oneZ : Z = pos (suc zero)
zeroZ : Z = pos zero
moneZ : Z = neg zero
mtwoZ : Z = neg (suc zero)

data S1 = base1
        | loop1 <i> [ (i=0) -> base1
                    , (i=1) -> base1 ]

data S2 = base2
        | loop2 <i j> [ (i=0) -> base2
                      , (i=1) -> base2
                      , (j=0) -> base2
                      , (j=1) -> base2]

data S3 = base3
        | loop3 <i j k> [ (i=0) -> base3
                        , (i=1) -> base3
                        , (j=0) -> base3
                        , (j=1) -> base3
                        , (k=0) -> base3
                        , (k=1) -> base3]

loopS1 : U = Path S1 base1 base1
loop : loopS1 = <i> loop1{S1} @ i

-- Pointed types
ptType : U = (A : U) * A
pt (A : ptType) : A.1 = A.2

boolpt : ptType = (bool,true)
S1pt : ptType = (S1,base1)
S2pt : ptType = (S2,base2)
S3pt : ptType = (S3,base3)

-- The first 3 loop spaces of a pointed type.
-- TODO: Maybe defined these by induction on n as in experiments/pointed.ctt?
Omega (A : ptType) : ptType = (Path A.1 (pt A) (pt A),<_> pt A)
Omega2 (A : ptType) : ptType = Omega (Omega A)
Omega3 (A : ptType) : ptType = Omega2 (Omega A)

mapOmegaRefl (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega A).1) :
  (Omega (B, h (pt A))).1 = <i> h (p @ i)

mapOmegaRefl2 (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega2 A).1) :
  (Omega2 (B, h (pt A))).1 = <i j> h (p @ i @ j)

mapOmegaRefl3 (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega3 A).1) :
  (Omega3 (B, h (pt A))).1 = <i j k> h (p @ i @ j @ k)


data join (A B : U) = inl (a : A)
                    | inr (b : B)
                    | push (a : A) (b : B) <i> [ (i = 0) -> inl a
                                               , (i = 1) -> inr b ]

pushP (A B : U) (a : A) (b : B) : Path (join A B) (inl a) (inr b) =
  <i> push {join A B} a b @ i

joinpt (A : ptType) (B : U) : ptType = (join A.1 B,inl (pt A))

--         v
--    b0 -----> b1
--    |         |
--    |         |
-- r0 |         | r1
--    |         |
--    a0 -----> a1
--         u
Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (Path A (u @ i) (v @ i))) r0 r1

-- The first type:
T1 : U = PathP (<i> PathP (<j> Path (join S1 S1)
                                    (inl (loop @ i)) (inr (loop @ j)))
                          (<j> pushP S1 S1 (loop @ i) base1 @ j)
                          (<j> pushP S1 S1 (loop @ i) base1 @ j))
               (<i j> pushP S1 S1 base1 (loop @ i) @ j)
               (<i j> pushP S1 S1 base1 (loop @ i) @ j)

-- The second type without loop:
T2 : U = PathP (<i> PathP (<j> Path (join S1 S1)
                                    (inl base1) (inr base1))
                          (<j> pushP S1 S1 base1 base1 @ j)
                          (<j> pushP S1 S1 base1 base1 @ j))
               (<i j> pushP S1 S1 base1 base1 @ j)
               (<i j> pushP S1 S1 base1 base1 @ j)

-- Direct equality in the universe:
T12 : Path U T1 T2 = <k>
         PathP (<i> PathP (<j> Path (join S1 S1)
                                    (inl (loop @ i /\ -k)) (inr (loop @ j /\ -k)))
                          (<j> pushP S1 S1 (loop @ i /\ -k) base1 @ j)
                          (<j> pushP S1 S1 (loop @ i /\ -k) (loop @ -k) @ j))
               (<i j> pushP S1 S1 base1 (loop @ i /\ -k) @ j)
               (<i j> pushP S1 S1 (loop @ -k) (loop @ i /\ -k) @ j)

-- Let cubicaltt do the job for us:
cubestep1 : T2 = transGen T12 0 (<i j k> pushP S1 S1 (loop @ i) (loop @ j) @ k)

-- Finish it up by hand:
goalcube : Path (Path (Path (join S1 S1)
                            (inl base1) (inl base1))
                      (<_> inl base1) (<_> inl base1))
                (<_ _> inl base1) (<_ _> inl base1) =
  <i j k> hcomp (join S1 S1)
                (cubestep1 @ i @ j @ k)
                [ (k=0) -> <l> inl base1
                , (k=1) -> <l> pushP S1 S1 base1 base1 @ -l
                , (j=0) -> <l> pushP S1 S1 base1 base1 @ k /\ -l
                , (j=1) -> <l> pushP S1 S1 base1 base1 @ k /\ -l
                , (i=0) -> <l> pushP S1 S1 base1 base1 @ k /\ -l
                , (i=1) -> <l> pushP S1 S1 base1 base1 @ k /\ -l
                ]


e : S3 -> join S1 S1 = split
  base3 -> inl base1
  loop3 @ i j k -> goalcube @ i @ j @ k

eInvAux2 : S1 -> Path (Path S3 base3 base3) (<_> base3) (<_> base3) = split
  base1 -> <_ _> base3
  loop1 @ i -> <j k> loop3{S3} @ i @ j @ k

eInvAux (x : S1) : S1 -> Path S3 base3 base3 = split
  base1 -> <_> base3
  loop1 @ i -> eInvAux2 x @ i

eInv : join S1 S1 -> S3 = split
  inl x -> base3
  inr y -> base3
  push x y @ i -> eInvAux x y @ i

merid : S1 -> Path S2 base2 base2 = split
  base1 -> <_> base2
  loop1 @ i -> <j> loop2{S2} @ i @ j

alpha : join S1 S1 -> S2 = split
  inl x -> base2
  inr y -> base2
  push x y @ i -> compPath S2 base2 base2 base2 (merid y) (merid x) @ i

--
constSquare (A : U) (a : A) (p : Path A a a) : Square A a a a a p p p p =
  <i j> hcomp A a [ (i = 0) -> <k> p @ (j \/ - k)
                  , (i = 1) -> <k> p @ (j /\ k)
                  , (j = 0) -> <k> p @ (i \/ - k)
                  , (j = 1) -> <k> p @ (i /\ k)]

fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)
isContr (A : U) : U = (x : A) * ((y : A) -> Path A x y)
prop (A : U) : U = (a b : A) -> Path A a b
set (A : U) : U = (a b : A) -> prop (Path A a b)

isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)

equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

contrSingl (A : U) (a b : A) (p : Path A a b) :
  Path ((x : A) * Path A a x) (a,<_>a) (b,p) = <i> (p @ i,<j> p @ i/\j)

subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transGen (<i> P (p @ i)) 0 e

J (A : U) (a : A) (C : (x : A) -> Path A a x -> U)
  (d : C a (<_> a)) (x : A) (p : Path A a x) : C x p =
    subst ((x : A) * Path A a x) T (a,<_> a) (x, p) (contrSingl A a x p) d
      where T (z : (x : A) * Path A a x) : U = C (z.1) (z.2)

idIsEquiv (A : U) : isEquiv A A (idfun A) =
  \(a : A) -> ((a,<_>a),\(z : (x : A) * Path A a x) -> contrSingl A a z.1 z.2)

idEquiv (A : U) : equiv A A = (idfun A,idIsEquiv A)

-- Unfolded direct proof. This has a simpler normal form without transGen's!
propIsEquivDirect (A B : U) (f : A -> B) : prop (isEquiv A B f) =
  \(p q : isEquiv A B f) ->
  <i> \(y : B) ->
    let p0 : A = (p y).1.1
        p1 : Path B y (f p0) = (p y).1.2
        p2 : (w1 : fiber A B f y) -> Path (fiber A B f y) (p0,p1) w1 =
         (p y).2
        q0 : A = (q y).1.1
        q1 : Path B y (f q0) = (q y).1.2
        q2 : (w1 : fiber A B f y) -> Path (fiber A B f y) (q0,q1) w1 =
         (q y).2
        alpha : Path (fiber A B f y) (p0,p1) (q0,q1) = p2 (q0,q1)
    in (alpha @ i,
       \(w : fiber A B f y) ->
          let x : A = w.1
              wx : Path B y (f x) = w.2
              alpha1 : Path A p0 q0 = <i> (alpha @ i).1
              alpha2 : PathP (<i> Path B y (f (alpha1 @ i))) p1 q1 =
                <i> (alpha @ i).2
              p2w1 : Path A p0 x = <i> (p2 w @ i).1
              q2w1 : Path A q0 x = <i> (q2 w @ i).1
              p2w2 : PathP (<i> Path B y (f (p2w1 @ i))) p1 wx = <i> (p2 w @ i).2
              q2w2 : PathP (<i> Path B y (f (q2w1 @ i))) q1 wx = <i> (q2 w @ i).2
              sq1 : PathP (<j> Path A (alpha1 @ j) x) p2w1 q2w1 =
                    <i j> hcomp A (p2w1 @ i \/ j)
                                 [ (i = 0) -> <k> p2w1 @ j
                                 , (i = 1) -> <k> q2w1 @ j \/ -k
                                 , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).1
                                 , (j = 1) -> <k> x ]
              sq2 : PathP (<i> PathP (<j> Path B y (f (sq1 @ i @ j)))
                                     (alpha2 @ i) wx)
                          p2w2 q2w2 =
                     <i j l> hcomp B (p2w2 @ i \/ j @ l)
                                 [ (i = 0) -> <k> p2w2 @ j @ l
                                 , (i = 1) -> <k> q2w2 @ j \/ -k @ l
                                 , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).2 @ l
                                 , (j = 1) -> <k> wx @ l
                                 , (l = 0) -> <k> y
                                 , (l = 1) -> <k> f (hfill A (p2w1 @ i \/ j)
                                                        [ (i = 0) -> <k> p2w1 @ j
                                                        , (i = 1) -> <k> q2w1 @ j \/ -k
                                                        , (j = 0) -> <k> (p2 (q2 w @ -k) @ i).1
                                                        , (j = 1) -> <k> x ] @ k)
                                 ]
          in <j> (sq1 @ i @ j,sq2 @ i @ j))

ua (A B : U) (e : equiv A B) : Path U A B =
  <i> Glue B [ (i = 0) -> (A,e)
             , (i = 1) -> (B,idEquiv B) ]

rotLoop : (a : S1) -> Path S1 a a = split
  base1 -> <i> loop1{S1} @ i
  loop1 @ i -> constSquare S1 base1 (<i> loop1{S1} @ i) @ i

rot : S1 -> S1 -> S1 = split
  base1 -> \(y : S1) -> y
  loop1 @ i -> \(y : S1) -> rotLoop y @ i

-- Specialized version of pathSIntro for S1
pathSIntroS1 (C : S1 -> U) (c : C base1)
           (w : Path (C base1) (subst S1 C base1 base1 loop c) c) :
  PathP (<i> C (loop @ i)) c c =
  transGen (<j> PathP (<i> C (loop @ -j \/ i))
                      (transGen (<i> C (loop @ -j /\ i)) j c) c) 0 w

s1elim (C : S1 -> U) (c : C base1) (p : Path (C base1) (subst S1 C base1 base1 loop c) c) :
  (x : S1) -> C x = split
  base1 -> c
  loop1 @ i -> pathSIntroS1 C c p @ i

rotIsEquiv : (a : S1) -> isEquiv S1 S1 (rot a) =
  s1elim (\(x : S1) -> isEquiv S1 S1 (rot x))
         (idIsEquiv S1) p
   where
   p : Path (isEquiv S1 S1 (rot base1))
            (subst S1 (\(x : S1) -> isEquiv S1 S1 (rot x)) base1 base1 loop (idIsEquiv S1)) (idIsEquiv S1) =
              propIsEquivDirect S1 S1 (rot base1) (subst S1 (\(x : S1) -> isEquiv S1 S1 (rot x))
                                 base1 base1 loop (idIsEquiv S1)) (idIsEquiv S1)

rotpath (x : S1) : Path U S1 S1 = ua S1 S1 (rot x, rotIsEquiv x)

HopfSquare (A : U) : Path (Path U A A) (ua A A (idEquiv A)) (<_> A) =
  <j i> Glue A [ (i = 0) -> (A,idEquiv A)
               , (i = 1) -> (A,idEquiv A)
               , (j = 1) -> (A,idEquiv A) ]

Hopf : S2 -> U = split
  base2 -> S1
  loop2 @ i j -> hcomp U (rotpath (loop @ i) @ j)
                       [ (i=0) -> <k> HopfSquare S1 @ k @ j
                       , (i=1) -> <k> HopfSquare S1 @ k @ j
                       , (j=0) -> <_> S1
                       , (j=1) -> <_> S1 ]

-----

data N0 =

not (A : U) : U = A -> N0
efq (A : U) : N0 -> A = split {}

-- Z is a set using Hedberg
data or (A B : U) = inl (a : A)
                  | inr (b : B)

data Unit = tt

stable (A : U) : U = not (not A) -> A
const (A : U) (f : A -> A) : U = (x y : A) -> Path A (f x) (f y)

exConst (A : U) : U = (f:A -> A) * const A f
propN0 : prop N0 = \ (x y:N0) -> efq (Path N0 x y) x

propNot (A : U) : prop (not A) = \ (f g:not A) -> <i>\(x:A) -> (propN0 (f x) (g x))@i

dNot (A : U) (a : A) : not (not A) = \ (h : not A) -> h a

stableConst (A : U) (sA : stable A) : exConst A =
 (\ (x:A) -> sA (dNot A x),\ (x y:A) -> <i>sA (propNot (not A) (dNot A x) (dNot A y) @ i))

dec (A : U) : U = or A (not A)

decEqCong (A B : U) (f : A -> B) (g : B -> A) : dec A -> dec B = split
  inl a -> inl (f a)
  inr h -> inr (\ (b:B) -> h (g b))

decStable (A : U) : dec A -> stable A = split
 inl a -> \ (h :not (not A)) -> a
 inr b -> \ (h :not (not A)) -> efq A (h b)

discrete (A : U) : U = (a b : A) -> dec (Path A a b)

hedbergLemma (A: U) (a b:A) (f : (x : A) -> Path A a x -> Path A a x) (p : Path A a b) :
            Square A a a a b (<_> a) p (f a (<_> a)) (f b p) =
 comp (<i> Square A a a a (p @ i) (<_> a) (<j> p @ i /\ j)
                 (f a (<_> a)) (f (p @ i) (<j> p @ i /\ j)))
      (<i> f a (<_> a)) []

hedbergStable (A : U) (a b : A) (h : (x : A) -> stable (Path A a x))
        (p q : Path A a b) : Path (Path A a b) p q =
 <j i> comp (<_> A) a [ (j = 0) -> rem2 @ i
                      , (j = 1) -> rem3 @ i
                      , (i = 0) -> r
                      , (i = 1) -> rem4 @ j]
 where
   rem1 (x : A) : exConst (Path A a x) = stableConst (Path A a x) (h x)
   f (x : A) : Path A a x -> Path A a x  = (rem1 x).1
   fIsConst (x : A) : const (Path A a x) (f x) = (rem1 x).2
   rem4 : Square A a a b b (<_> a) (<_> b) (f b p) (f b q)  = fIsConst b p q
   r : Path A a a = f a (<_> a)
   rem2 : Square A a a a b (<_> a) p r (f b p) = hedbergLemma A a b f p
   rem3 : Square A a a a b (<_> a) q r (f b q) = hedbergLemma A a b f q

hedbergS (A : U) (h : (a x : A) -> stable (Path A a x)) : set A =
 \(a b : A) -> hedbergStable A a b (h a)

hedberg (A : U) (h : discrete A) : set A =
 \(a b : A) -> hedbergStable A a b (\(b : A) -> decStable (Path A a b) (h a b))

caseNat (A : U) (a0 aS : A) : nat -> A = split
 zero -> a0
 suc n -> aS

caseDNat (P:nat -> U) (a0 :P zero) (aS : (n:nat) -> P (suc n))
            : (n:nat) -> P n = split
 zero -> a0
 suc n -> aS n

znots (n : nat) : not (Path nat zero (suc n)) =
  \(h : Path nat zero (suc n)) -> subst nat (caseNat U nat N0) zero (suc n) h zero

snotz (n : nat) : not (Path nat (suc n) zero) =
  \(h : Path nat (suc n) zero) -> znots n (<i> h @ -i)

sucInj (n m : nat) (p : Path nat (suc n) (suc m)) : Path nat n m =
 <i> pred (p @ i)

discreteNat : discrete nat = split
 zero -> caseDNat (\(m : nat) -> dec (Path nat zero m)) (inl (<_> zero)) (\(m : nat) -> inr (znots m))
 suc n -> caseDNat (\(m : nat) -> dec (Path nat (suc n) m)) (inr (snotz n))
   (\(m : nat) -> decEqCong (Path nat n m) (Path nat (suc n) (suc m)) (\(p : Path nat n m) -> <i> suc (p @ i))
                  (sucInj n m) (discreteNat n m))

posNotneg (a b : nat) (h : Path Z (pos a) (neg b)) : N0 = subst Z T (pos a) (neg b) h tt
  where
  T : Z -> U = split
       pos _ -> Unit
       neg _ -> N0

negNotpos (a b : nat) (h : Path Z (neg b) (pos a)) : N0 = subst Z T (neg b) (pos a) h tt
  where
  T : Z -> U = split
       pos _ -> N0
       neg _ -> Unit

injPos (a b : nat) (h : Path Z (pos a) (pos b)) : Path nat a b =
 subst Z T (pos a) (pos b) h (<_> a)
 where
   T : Z -> U = split
        pos c -> Path nat a c
        neg _ -> N0

injNeg (a b : nat) (h : Path Z (neg a) (neg b)) : Path nat a b =
  subst Z T (neg a) (neg b) h (<_> a)
  where
    T : Z -> U = split
         pos _ -> N0
         neg c -> Path nat a c

discreteZ : discrete Z = split
  pos a -> split@((z1 : Z) -> dec (Path Z (pos a) z1)) with
             pos a1 -> let rem : dec (Path nat a a1) -> dec (Path Z (pos a) (pos a1)) = split
                             inl p -> inl (<i> pos (p @ i))
                             inr h -> inr (\(p : Path Z (pos a) (pos a1)) -> h (injPos a a1 p))
                       in rem (discreteNat a a1)
             neg b -> inr (posNotneg a b)
  neg b -> split@((z1 : Z) -> dec (Path Z (neg b) z1)) with
             pos a -> inr (negNotpos a b)
             neg b1 -> let rem : dec (Path nat b b1) -> dec (Path Z (neg b) (neg b1)) = split
                             inl p -> inl (<i> neg (p @ i))
                             inr h -> inr (\(p : Path Z (neg b) (neg b1)) -> h (injNeg b b1 p))
                       in rem (discreteNat b b1)

ZSet : set Z = hedberg Z discreteZ


-- alternative proof that sucZ is an equiv, not using the "grad lemma"

sucZ : Z -> Z = split
  pos u -> pos (suc u)
  neg v -> auxsucZ v
    where
    auxsucZ : nat -> Z = split
      zero  -> pos zero
      suc n -> neg n

predZ : Z -> Z = split
  pos u -> auxpredZ u
    where
    auxpredZ : nat -> Z = split
      zero  -> neg zero
      suc n -> pos n
  neg v -> neg (suc v)

predsucZ : (x : Z) -> Path Z (predZ (sucZ x)) x = split
  pos u -> <_> pos u
  neg v -> lem v
   where
    lem : (u : nat) -> Path Z (predZ (sucZ (neg u))) (neg u) = split
      zero  -> <_> neg zero
      suc n -> <_> neg (suc n)

sucpredZ : (x : Z) -> Path Z (sucZ (predZ x)) x = split
  pos u -> lem u
   where
    lem : (u : nat) -> Path Z (sucZ (predZ (pos u))) (pos u) = split
      zero  -> <_> pos zero
      suc n -> <_> pos (suc n)
  neg v -> <_> neg v

-- Maybe we can generalize the notion of being a set to allow
-- arbitrary paths on the sides and not just refl?
gengoal (A : U) (hA : set A) (x y : A) (p : Path A x y) : (z : A) (r : Path A y z) (q : Path A x z) ->
  PathP (<i> Path A x (r @ i)) p q =
  J A y (\(z : A) (r : Path A y z) -> (q : Path A x z) -> PathP (<i> Path A x (r @ i)) p q)
   (hA x y p)

ctr (y : Z) : fiber Z Z sucZ y = (predZ y,<i> sucpredZ y @ -i)

contr (y : Z) (y' : fiber Z Z sucZ y) : Path ((x : Z) * Path Z y (sucZ x)) (ctr y) y' =
    let p1 : Path Z (predZ y) y'.1 =
          compPath Z (predZ y) (predZ (sucZ y'.1)) y'.1
                   (<i> predZ (y'.2 @ i)) (predsucZ y'.1)
        prf1 : Path Z (sucZ (predZ y)) (sucZ y'.1) = <i> sucZ (p1 @ i)
        prf2 : Path Z y (sucZ (predZ y)) = <i> sucpredZ y @ -i
        p2 : PathP (<i> Path Z y (prf1 @ i)) prf2 y'.2 =
          gengoal Z ZSet y (sucZ (predZ y)) prf2 (sucZ y'.1) prf1 y'.2
    in <i> (p1 @ i,p2 @ i)

equivSucZ : isEquiv Z Z sucZ = \(y : Z) -> (ctr y,contr y)

sucPathZ : Path U Z Z = ua Z Z (sucZ,equivSucZ)

-- Covering space of the circle
helix : S1 -> U = split
  base1 -> Z
  loop1 @ i -> sucPathZ @ i


-- tests

test0To2 : (Omega3 S3pt).1 = <i j k> loop3{S3} @ i @ j @ k

f3 : (Omega3 S3pt).1 -> (Omega3 (joinpt S1pt S1)).1 =
  mapOmegaRefl3 S3pt (join S1 S1) e

test0To3 : (Omega3 (joinpt S1pt S1)).1 = f3 test0To2

f4 : (Omega3 (joinpt S1pt S1)).1 -> (Omega3 S2pt).1 =
  mapOmegaRefl3 (joinpt S1pt S1) S2 alpha

test0To4 : (Omega3 S2pt).1 = f4 test0To3


-- This is the problematic stuff:

innerpath :
  PathP (<j> Path S1
                 (transGen (<k> Hopf (test0To4 @ 0 @ j @ k)) 0 base1)
                 (transGen (<k> Hopf (test0To4 @ 1 @ j @ k)) 0 base1))
        (<j> transGen (<k> Hopf (test0To4 @ 0 @ j @ k)) 0 base1)
        (<j> transGen (<k> Hopf (test0To4 @ 1 @ j @ k)) 0 base1) =
  <i j> transGen (<k> Hopf (test0To4 @ i @ j @ k)) 0 base1

problem : Path Z (pos zero) (pos zero) =
  <i> transGen (<j> helix (innerpath @ i @ j)) 0 (pos zero)

-- This term contains a ton of hcomp U:
problempath : Path U (helix (transGen (<k> Hopf (test0To4 @ k @ 0 @ k)) 0 base1))
                     (helix (transGen (<k> Hopf (test0To4 @ k @ 1 @ k)) 0 base1)) =
              <j> helix (transGen (<k> Hopf (test0To4 @ k @ j @ k)) 0 base1)

