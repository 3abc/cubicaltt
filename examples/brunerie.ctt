{- 

The structure of the file is as follows (numbers as in Appendix B in
Guillaume's thesis):

B.3 Suspension and spheres

B.4 Pointed types, pointed maps and loop spaces

B.5 Loop space of a suspension

B.6 The 3-sphere and the join of two circles

B.7 The main map

B.8 The map defining pi3(S2)

B.9 Going back to pi2(S2)

B.10 Loop space of truncations

B.11 Down one more dimension

B.2 The definition

-}
module brunerie where

data bool = false | true
data nat = zero | suc (n : nat)

idfun (A : U) (a : A) : A = a

{- Z is represented as:

  +2 = pos (suc (suc zero))
  +1 = pos (suc zero)
   0 = pos zero
  -1 = neg zero
  -2 = neg (suc zero)

-}
data Z = pos (n : nat) | neg (n : nat)

twoZ : Z = pos (suc (suc zero))
oneZ : Z = pos (suc zero)
zeroZ : Z = pos zero
moneZ : Z = neg zero
mtwoZ : Z = neg (suc zero)

Path (A : U) (a0 a1 : A) : U = PathP (<i> A) a0 a1

Sigma (A : U) (B : A -> U) : U = (x : A) * B x
refl (A : U) (a : A) : Path A a a = <i> a

Square (A : U) (a0 a1 b0 b1 : A)
               (u : Path A a0 a1) (v : Path A b0 b1)
               (r0 : Path A a0 b0) (r1 : Path A a1 b1) : U
  = PathP (<i> (PathP (<j> A) (u @ i) (v @ i))) r0 r1

constSquare (A : U) (a : A) (p : Path A a a) : Square A a a a a p p p p =
  <i j> hcomp A a [ (i = 0) -> <k> p @ (j \/ - k)
                  , (i = 1) -> <k> p @ (j /\ k)
                  , (j = 0) -> <k> p @ (i \/ - k)
                  , (j = 1) -> <k> p @ (i /\ k)]

compPath (A : U) (a b c : A) (p : Path A a b) (q : Path A b c) : Path A a c =
  <i> hcomp A (p @ i) [ (i =0) -> <j> a, (i = 1) -> q ]

-- p ; p^-1 = 1
compPathInv (A : U) (a b : A) (p : Path A a b) :
  Path (Path A a a) (compPath A a b a p (<i> p @ -i)) (<_> a) =
    <k j> hcomp A (p @ j /\ -k)
                  [ (j = 0) -> <_> a
                  , (j = 1) -> <i> p @ -i /\ -k
                  , (k = 1) -> <_> a ]

-- p^-1 ; p = 1
compInvPath (A : U) (a b : A) (p : Path A a b) :
  Path (Path A b b) (compPath A b a b (<i> p @ -i) p)  (<_> b) =
   <j i> hcomp A (p @ -i \/ j)
                 [ (i = 0) -> <_> b
                 , (j = 1) -> <_> b
                 , (i = 1) -> <k> p @ j \/ k ]


--------------------------------------------------------------------------------
-- B.3 Suspension and spheres

-- The circle
data S1 = base
        | loop <i> [ (i=0) -> base
                   , (i=1) -> base]

loopS1 : U = Path S1 base base
loopP : loopS1 = <i> loop{S1} @ i
invLoop : loopS1 = <i> loopP @ -i
compS1 : loopS1 -> loopS1 -> loopS1 = compPath S1 base base base

triv : loopS1 = <i> base
oneTurn (l : loopS1) : loopS1 = compS1 l loopP
backTurn (l : loopS1) : loopS1 = compS1 l invLoop

itLoop : nat -> loopS1 = split
 zero -> triv
 suc n -> oneTurn (itLoop n)

itLoopNeg : nat -> loopS1 = split
 zero -> invLoop
 suc n -> backTurn (itLoopNeg n)

loopIt : Z -> loopS1 = split
 pos n -> itLoop n
 neg n -> itLoopNeg n

-- Suspension
data susp (A : U) = north
                  | south
                  | merid (a : A) <i> [ (i=0) -> north
                                      , (i=1) -> south ]

meridP (A : U) (a : A) : Path (susp A) north south =
  <i> merid{susp A} a @ i


-- The 2 and 3 spheres. Maybe define directly instead?
S2 : U = susp S1
S3 : U = susp S2


--------------------------------------------------------------------------------
-- B.4 Pointed types, pointed maps and loop spaces

-- Pointed types
ptType : U = (A : U) * A
pt (A : ptType) : A.1 = A.2

boolpt : ptType = (bool,true)
susppt (A : U) : ptType = (susp A,north)
S1pt : ptType = (S1,base)
S2pt : ptType = susppt S1
S3pt : ptType = susppt S2

ptMap (A B : ptType) : U = (f : A.1 -> B.1) * (Path B.1 (f (pt A)) (pt B))

-- The first 3 loop spaces of a pointed type.
-- TODO: Maybe defined these by induction on n as in experiments/pointed.ctt?
Omega (A : ptType) : ptType = (Path A.1 (pt A) (pt A),<_> pt A)
Omega2 (A : ptType) : ptType = Omega (Omega A)
Omega3 (A : ptType) : ptType = Omega2 (Omega A)

kanOp (A : U) (a : A) (p : Path A a a) (b : A) (q : Path A a b) : Path A b b =
 <i> hcomp A (p @ i) [ (i = 0) -> q, (i = 1) -> q ]

kanOpRefl (A : U) (a b : A) (q : Path A a b) :
  Path (Path A b b) (kanOp A a (<i> a) b q) (<_> b) =
    <j i> hcomp A (q @ j) [ (i = 0) -> <k> q @ j \/ k
                          , (i = 1) -> <k> q @ j \/ k
                          , (j = 1) -> <k> b ]

mapOmega (A B : ptType) (f : ptMap A B) : ptMap (Omega A) (Omega B) = (g,pg)
  where
  g (p : (Omega A).1) : (Omega B).1 =
   kanOp B.1 (f.1 (pt A)) (<i>f.1 (p@i)) (pt B) f.2
  pg : Path (Omega B).1 (g (pt (Omega A))) (pt (Omega B)) =
    kanOpRefl B.1 (f.1 (pt A)) (pt B) f.2

mapOmega2 (A B : ptType) (f : ptMap A B) : ptMap (Omega2 A) (Omega2 B) =
  mapOmega (Omega A) (Omega B) (mapOmega A B f)

mapOmega3 (A B : ptType) (f : ptMap A B) : ptMap (Omega3 A) (Omega3 B) =
  mapOmega (Omega2 A) (Omega2 B) (mapOmega2 A B f)

-- Simplified mapOmega when the function is pointed by reflexivity
mapOmegaRefl (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega A).1) :
  (Omega (B, h (pt A))).1 = <i> h (p @ i)

mapOmegaRefl2 (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega2 A).1) :
  (Omega2 (B, h (pt A))).1 = <i j> h (p @ i @ j)
  -- mapOmegaRefl (Omega A) (Omega (B,h (pt A))).1 (mapOmegaRefl A B h) p

mapOmegaRefl3 (A : ptType) (B : U) (h : A.1 -> B) (p : (Omega3 A).1) :
  (Omega3 (B, h (pt A))).1 = <i j k> h (p @ i @ j @ k)
  -- mapOmegaRefl2 (Omega A) (Omega (B,h (pt A))).1 (mapOmegaRefl A B h)

--------------------------------------------------------------------------------
-- B.5 Loop space of a suspension

phi (A : ptType) : ptMap A (Omega (susppt A.1)) = (g,pg)
  where
  g (a : A.1) : (Omega (susppt A.1)).1 =
    let p1 : Path (susp A.1) north south = meridP A.1 a
        p2 : Path (susp A.1) south north = <i> meridP A.1 (pt A) @ -i
    in compPath (susp A.1) north south north p1 p2
  pg : Path (Omega (susppt A.1)).1 (g (pt A)) (pt (Omega (susppt A.1))) =
    let p : Path (Path (susp A.1) north north) (g (pt A)) (<_> north) =
            compPathInv (susp A.1) north south (meridP A.1 (pt A))
    in p


--------------------------------------------------------------------------------
-- B.6 The 3-sphere and the join of two circles

data join (A B : U) = inl (a : A)
                    | inr (b : B)
                    | push (a : A) (b : B) <i> [ (i = 0) -> inl a
                                               , (i = 1) -> inr b ]

pushP (A B : U) (a : A) (b : B) : Path (join A B) (inl a) (inr b) =
  <i> push {join A B} a b @ i

joinpt (A : ptType) (B : U) : ptType = (join A.1 B,inl (pt A))


-- B.6.1 Join and associativity

r2lInr (A B C : U) : join B C -> join (join A B) C = split
  inl b -> inl (inr b)
  inr c -> inr c
  push b c @ i -> pushP (join A B) C (inr b) c @ i

r2lPushInl (A B C : U) (a : A) (b : B) :
  Path (join (join A B) C) (inl (inl a)) (inl (inr b)) = <i> inl (pushP A B a b @ i)

r2lSquare (A B C : U) (a : A) (b : B) (c : C) :
        PathP (<i> Path (join (join A B) C) (inl (pushP A B a b @ i)) (inr c))
            (pushP (join A B) C (inl a) c) (pushP (join A B) C (inr b) c)
 = <i j> pushP (join A B) C (pushP A B a b @ i) c @ j

opr2l (A : U) (a b c : A) (p : Path A a c) (q : Path A a b) (r : Path A b c)
      (sq : Square A a b c c q (<_> c) p r) :
      Square A a a b c (<_> a) r q p =
         <i j> hcomp A (p @ i) [ (i = 0) -> <k> q @ j /\ k
                               , (i = 1) -> <k> p @ j \/ -k
                               , (j = 0) -> <k> p @ i /\ -k
                               , (j = 1) -> <k> sq @ k @ i ]

r2lPushPush (A B C : U) (a : A) (b : B) (c : C) :
  Square (join (join A B) C) (inl (inl a)) (inl (inl a)) (inl (inr b)) (inr c)
         (<_> inl (inl a)) (pushP (join A B) C (inr b) c)
         (r2lPushInl A B C a b) (pushP (join A B) C (inl a) c) =
  opr2l (join (join A B) C) (inl (inl a)) (inl (inr b)) (inr c)
        (pushP (join A B) C (inl a) c) (r2lPushInl A B C a b)
        (pushP (join A B) C (inr b) c) (r2lSquare A B C a b c)

r2lPush (A B C : U) (a : A) :
  (bc : join B C) -> Path (join (join A B) C) (inl (inl a)) (r2lInr A B C bc) = split
    inl b -> r2lPushInl A B C a b
    inr c -> pushP (join A B) C (inl a) c
    push b c @ i -> r2lPushPush A B C a b c @ i

joinassoc1 (A B C : U) : join A (join B C) -> join (join A B) C = split
  inl a  -> inl (inl a)
  inr bc -> r2lInr A B C bc
  push a bc @ i -> r2lPush A B C a bc @ i


-- Map from [join (join A B) C] to [join A (join B C)]

l2rInl (A B C : U) : join A B -> join A (join B C) = split
  inl a    -> inl a
  inr b    -> inr (inl b)
  push a b @ i -> pushP A (join B C) a (inl b) @ i

l2rPushInr (A B C : U) (b : B) (c : C) :
  Path (join A (join B C)) (inr (inl b)) (inr (inr c)) = <i> inr (pushP B C b c @ i)

l2rSquare (A B C : U) (a : A) (b : B) (c : C) :
  PathP (<i> Path (join A (join B C)) (inl a) (inr (pushP B C b c @ i)))
        (<i> pushP A (join B C) a (inl b) @ i) (<i> pushP A (join B C) a (inr c) @ i) =
        <i j> pushP A (join B C) a (pushP B C b c @ i) @ j

opl2r (A : U) (a b c : A) (p : Path A a c) (q : Path A a b) (r : Path A b c)
      (sq : Square A a a b c (<_> a) r q p) :
      Square A a b c c q (<_> c) p r = undefined
      -- <i j>hcomp A (sq@j@i) [(i=0) -> <k>p@(j/\k),(j=1) -> <k>p@(i\/k)]

l2rPushPush (A B C : U) (a : A) (b : B) (c : C) :
  Square (join A (join B C)) (inl a) (inr (inl b)) (inr (inr c)) (inr (inr c))
         (pushP A (join B C) a (inl b)) (<_> inr (inr c))
         (pushP A (join B C) a (inr c)) (l2rPushInr A B C b c) = 
  opl2r (join A (join B C)) (inl a) (inr (inl b)) (inr (inr c))
        (pushP A (join B C) a (inr c)) (pushP A (join B C) a (inl b)) (l2rPushInr A B C b c)
        (l2rSquare A B C a b c)

l2rPush (A B C : U) (c : C) : (u : join A B) ->
            Path (join A (join B C)) (l2rInl A B C u) (inr (inr c)) = split
  inl a -> pushP A (join B C) a (inr c)
  inr b -> l2rPushInr A B C b c
  push a b @ i -> l2rPushPush A B C a b c @ i

joinassoc2 (A B C : U) : join (join A B) C -> join A (join B C) = split
  inl jab -> l2rInl A B C jab
  inr c   -> inr (inr c)
  push p q @ i -> l2rPush A B C q p @ i


mapJoin (A A' B B' : U) (f : A -> A') (g : B -> B') : join A B -> join A' B' = split
  inl a -> inl (f a)
  inr b -> inr (g b)
  push a b @ i -> pushP A' B' (f a) (g b) @ i

-- TODO: mapJoin is pointed as soon as f is (this is not needed I think)
-- mapJoinPt (A A' : ptType) (B B' : U) (f : ptMap A A') (g : B -> B') :
--   ptMap (joinpt A B) (joinpt A' B') = undefined


-- B.6.2 Suspension and join with the booleans
-- It is not necessary that the maps here are pointed yet, we fix it
-- in the end after composing them

psi (A : U) : susp A -> join bool A = split
  north -> inl true
  south -> inl false
  merid a @ i -> compPath (join bool A) (inl true) (inr a) (inl false)
                          (pushP bool A true a) (<i> pushP bool A false a @ -i) @ i

psiinv (A : U) : join bool A -> susp A = split
  inl b ->
    let case : (b : bool) -> susp A = split
          false -> south
          true  -> north
    in case b
  inr a -> south
  push b a @ i ->
    let case (a : A) : (b : bool) -> Path (susp A) (psiinv A (inl b)) south = split
          false -> <_> south
          true  -> meridP A a
    in case a b @ i

-- I define c by going via susp bool
-- TODO: maybe do it directly?

suspBoolToS1 : susp bool -> S1 = split
  north   -> base
  south   -> base
  merid b @ i ->
    let case : bool -> Path S1 base base = split
          false -> loopP
          true  -> <_> base
    in case b @ i

s1ToSuspBool : S1 -> susp bool = split
  base -> north
  loop @ i -> compPath (susp bool) north south north
                       (meridP bool false) (<i> meridP bool true @ -i) @ i

c (x : join bool bool) : S1 = suspBoolToS1 (psiinv bool x)

cinv (x : S1) : join bool bool = psi bool (s1ToSuspBool x)

-- B.6.3 Equivalence between S3 and join S1 S1

-- The map e
e (x : S3) : join S1 S1 =
  let x1 : join bool S2 = psi S2 x
      x2 : join bool (join bool S1) =
        mapJoin bool bool S2 (join bool S1) (idfun bool) (psi S1) x1
      x3 : join (join bool bool) S1 = joinassoc1 bool bool S1 x2
      res : join S1 S1 = mapJoin (join bool bool) S1 S1 S1 c (idfun S1) x3
  in res

einv (x : join S1 S1) : S3 =
  let x1 : join (join bool bool) S1 =
        mapJoin S1 (join bool bool) S1 S1 cinv (idfun S1) x
      x2 : join bool (join bool S1) = joinassoc2 bool bool S1 x1
      x3 : join bool S2 =
        mapJoin bool bool (join bool S1) S2 (idfun bool) (psiinv S1) x2
      res : S3 = psiinv S2 x3
  in res

--------------------------------------------------------------------------------
-- B.7 The main map

-- A modified version of the main map alpha, which is equal to the
-- other one (to be checked) but pointed by reflexivity
prealpha : join S1 S1 -> S2 = split
  inl x -> north
  inr y -> north
  push x y @ i ->
    -- A: I think there must be a bug in the old version when
    -- typechecking path constructors (we use merid{S2} there...)
    compPath S2 north south north (meridP S1 x) (<i> meridP S1 y @ -i) @ i

alpha : ptMap (joinpt S1pt S1) S2pt = (prealpha, <_> north)



--------------------------------------------------------------------------------
-- B.8 The map defining pi3(S2)

-- This is where things get complicated and slow. This is also the place where
-- univalence is first needed.


-- Basic results about equivalences and lower h-levels:

isContr (A : U) : U = (x : A) * ((y : A) -> Path A x y)

prop (A : U) : U = (a b : A) -> Path A a b
set (A : U) : U = (a b : A) -> prop (Path A a b)
groupoid (A : U) : U = (a b : A) -> set (Path A a b)

fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)

isEquiv (A B : U) (f : A -> B) : U = (y : B) -> isContr (fiber A B f y)

equiv (A B : U) : U = (f : A -> B) * isEquiv A B f

-- This can be proved in many ways, not sure which is the most efficient
propIsContr (A : U) (z0 z1 : isContr A) : Path (isContr A) z0 z1 =
 <j> (p0 a1 @ j
     ,\(x : A) -> <i> hcomp A (lem1 x@i@j)
                              [ (i=0) -> <k> p0 a1 @ j
                              , (i=1) -> <k> p0 x @ j \/ k
                              , (j=0) -> <k> p0 x @ i/\ k
                              , (j=1) -> <k> p1 x @ i ])
 where
  a0 : A = z0.1
  p0 : (x : A) -> Path A a0 x = z0.2
  a1 : A = z1.1
  p1 : (x : A) -> Path A a1 x = z1.2
  lem1 (x : A) : PathP (<i> Path A a0 (p1 x @ i)) (p0 a1) (p0 x) =
    <i j> p0 (p1 x @ i) @ j

propSet (A : U) (h : prop A) : set A =
 \(a b : A) (p q : Path A a b) ->
   <j i> hcomp A a [ (i=0) -> h a a
                       , (i=1) -> h a b
                       , (j=0) -> h a (p @ i)
                       , (j=1) -> h a (q @ i)]

propIsProp (A : U) : prop (prop A) =
  \(f g : prop A) -> <i> \(a b : A) ->
    propSet A f a b (f a b) (g a b) @ i

setIsProp (A : U) : prop (set A) =
 \(f g : set A) -> <i> \(a b :A) ->
   propIsProp (Path A a b) (f a b) (g a b) @ i

propPi (A : U) (B : A -> U) (h : (x : A) -> prop (B x))
       (f0 f1 : (x : A) -> B x) : Path ((x : A) -> B x) f0 f1
  = <i> \ (x:A) -> (h x (f0 x) (f1 x)) @ i

propIsEquiv (A B : U) (f : A -> B) : prop (isEquiv A B f) =
  \(u0 u1 : isEquiv A B f) -> <i> \(y : B) -> propIsContr (fiber A B f y) (u0 y) (u1 y) @ i

-- This opaque makes typechecking mu below faster, not sure if it breaks computation
opaque propIsEquiv

lemPropF (A : U) (P : A -> U) (pP : (x : A) -> prop (P x)) (a0 a1 :A)
         (p : Path A a0 a1) (b0 : P a0) (b1 : P a1) : PathP (<i> P (p @ i)) b0 b1 =
  <i> pP (p @ i) (comp (<j> P (p @ i/\ j)) b0 [ (i=0) -> <_> b0])
                 (comp (<j> P (p @ i\/ -j)) b1 [ (i=1) -> <_> b1]) @ i

lemSig (A : U) (B : A -> U) (pB : (x : A) -> prop (B x))
       (u v : (x:A) * B x) (p : Path A u.1 v.1) :
       Path ((x:A) * B x) u v = <i> (p @ i, lemPropF A B pB u.1 v.1 p u.2 v.2 @ i)

equivEq (A B : U) (v w : equiv A B) (p : Path (A -> B) v.1 w.1) : Path (equiv A B) v w =
  lemSig (A -> B) (isEquiv A B) (propIsEquiv A B) v w p

contrSingl (A : U) (a b : A) (p : Path A a b) :
  Path ((x : A) * Path A a x) (a,<_>a) (b,p) = <i> (p @ i,<j> p @ i/\j)

idIsEquiv (A : U) : isEquiv A A (idfun A) =
  \(a : A) -> ((a,<_>a)
              ,\(z : fiber A A (idfun A) a) -> contrSingl A a z.1 z.2)

idEquiv (A : U) : equiv A A = (idfun A,idIsEquiv A)

-- Univalence map
ua (A B : U) (e : equiv A B) : Path U A B =
  <i> Glue B [ (i = 0) -> (A,e)
             , (i = 1) -> (B,idEquiv B) ]

-- opaque ua

-- End of basics

-- B.8.1 The Hopf fibration

mu : S1 -> equiv S1 S1 = split
  base -> idEquiv S1
  loop @ i ->
    let f : (x : S1) -> Path S1 x x = split
          base -> loopP
          loop @ i -> constSquare S1 base loopP @ i
        goal : Path (equiv S1 S1) (idEquiv S1) (idEquiv S1) =
          equivEq S1 S1 (idEquiv S1) (idEquiv S1) (<j> \(x : S1) -> f x @ j)
    in goal @ i

Hopf : S2 -> U = split
  north -> S1
  south -> S1
  merid x @ i -> ua S1 S1 (mu x) @ i

-- Definition of the t map, this needs cleaning!

subst (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transGen (<i> P (p @ i)) 0 e

J (A : U) (a : A) (C : (x : A) -> Path A a x -> U)
  (d : C a (<_> a)) (x : A) (p : Path A a x) : C x p =
    subst ((x : A) * Path A a x) T (a,<_> a) (x, p) (contrSingl A a x p) d
      where T (z : (x : A) * Path A a x) : U = C (z.1) (z.2)

PathS (A : U) (P : A -> U) (a0 a1 : A) (p : Path A a0 a1) (u0 : P a0) (u1 : P a1) : U =
  PathP (<i> P (p @ i)) u0 u1

-- CLEAN THIS MESS!
-- TODO: is there a direct proof not involving J?
funExt1 (C B : U) (F : C -> U) (a : C) : (b : C) (p : Path C a b)
        (f : F a -> B) (g : F b -> B)
        (h : (x : F a) -> Path B (f x) (g (subst C F a b p x))) ->
        PathP (<i> F (p @ i) -> B) f g =
        let
            rem (f g : F a -> B) (h : (x : F a) -> Path B (f x) (g x)) : Path (F a -> B) f g =
              <i>\(x:F a) -> h x @ i
            P : (b:C) (p:Path C a b) -> U = \(b:C) (p:Path C a b) -> (f : F a -> B) (g : F b -> B)
                                            (h : (x : F a) -> Path B (f x) (g (subst C F a b p x)))
                                            -> PathP (<i> F (p @ i) -> B) f g
            rem1 (f g : F a -> B)
                 (h : (x : F a) -> Path B (f x) (g (transGen (<_> F a) 0 x)))
                 : Path (F a -> B) f g =
                     let
                         moo : Path (F a -> B) f (\(x : F a) -> g (transGen (<_> F a) 0 x)) =
                           <i> \(x : F a) -> h x @ i
                         boo' (x : F a) : Path (F a) x (hcomp (F a) (transGen (<_> F a) 0 x) []) =
                           fill (<_> F a) x []
                         boo'' (x : F a) : Path (F a) (transGen (<_> F a) 0 x) (hcomp (F a) (transGen (<_> F a) 0 x) []) = hfill (F a) (transGen (<_> F a) 0 x) []
                         boo''' (x : F a) : Path (F a) x (transGen (<_> F a) 0 x) =
                           compPath (F a) x (hcomp (F a) (transGen (<_> F a) 0 x) []) (transGen (<_> F a) 0 x) (boo' x) (<i> boo'' x @ -i)
                         boo (x : F a) : Path B (g x) (g (transGen (<_> F a) 0 x)) =
                           <i> g (boo''' x @ i)
                         boof : Path (F a -> B) (\(x : F a) -> g (transGen (<_> F a) 0 x)) g =
                           <i> \(x : F a) -> boo x @ -i
                     in compPath (F a -> B) f (\(x : F a) -> g (transGen (<_> F a) 0 x)) g moo boof
        in J C a (\ (b:C) (p:Path C a b) -> (f : F a -> B) (g : F b -> B)
            (h : (x : F a) -> Path B (f x) (g (subst C F a b p x)))
              -> PathP (<i> F (p @ i) -> B) f g) rem1

-- opaque funExt1

t : (x : S2) -> (Hopf x -> join S1 S1) = split
  north -> \(x : S1) -> inl x
  south -> \(x : S1) -> inr x
  merid x @ i ->
    let eq (y : S1) : Path (join S1 S1) (inl y) (inr (subst S2 Hopf north south (meridP S1 x) y)) =
          pushP S1 S1 y (subst S2 Hopf north south (meridP S1 x) y)
    in funExt1 S2 (join S1 S1) Hopf north south (meridP S1 x)
                  (\(y : S1) -> inl y) (\(y : S1) -> inr y) eq @ i

t' (xy : (x : S2) * Hopf x) : join S1 S1 = t xy.1 xy.2

-- B.8.2 Looping a fibration

-- TODO: define all of these directly? (like for Omega2, Omega3..)
fibOmega (B : ptType) (P : B.1 -> U) (f : P (pt B)) (p : (Omega B).1) : U =
  PathS B.1 P (pt B) (pt B) p f f

itOmega : nat -> ptType -> ptType = split
  zero  -> \(A : ptType) -> A
  suc n -> \(A : ptType) -> itOmega n (Omega A)

itFibOmega : (n : nat) (B : ptType) (P : B.1 -> U) (f : P (pt B)) -> (itOmega n B).1 -> U = split
  zero  -> \(B : ptType) (P : B.1 -> U) (f : P (pt B)) -> P
  suc n -> \(B : ptType) (P : B.1 -> U) (f : P (pt B)) ->
    itFibOmega n (Omega B) (fibOmega B P f) (<_> f)

itMapOmega : (n : nat) (A B : ptType) (h : ptMap A B) -> ptMap (itOmega n A) (itOmega n B) = split
  zero  -> \(A B : ptType) (h : ptMap A B) -> h
  suc n -> \(A B : ptType) (h : ptMap A B) -> itMapOmega n (Omega A) (Omega B) (mapOmega A B h)

totalFibOmega (B : ptType) (P : B.1 -> U) (f : P (pt B))
  (p : Sigma (Omega B).1 (fibOmega B P f)) : (Omega (Sigma B.1 P, (pt B, f))).1 =
  <i> (p.1 @ i,p.2 @ i)

itTotalFibOmega : (n : nat) (B : ptType) (P : B.1 -> U) (f : P (pt B))
  (x : Sigma (itOmega n B).1 (itFibOmega n B P f)) -> (itOmega n (Sigma B.1 P, (pt B, f))).1 = split
    zero  -> \(B : ptType) (P : B.1 -> U) (f : P (pt B)) (x : Sigma B.1 P) -> x
    suc n -> \(B : ptType) (P : B.1 -> U) (f : P (pt B))
              (x : Sigma (itOmega n (Omega B)).1 (itFibOmega n (Omega B) (fibOmega B P f) (<_> f))) ->
       let BOm : ptType = Omega B
           POm : BOm.1 -> U = fibOmega B P f
           fOm : Path (P (pt B)) f f = <_> f
           ih : (Sigma (itOmega n BOm).1 (itFibOmega n BOm POm fOm)) ->
                (itOmega n (Sigma BOm.1 POm, (pt BOm, fOm))).1 =
                  itTotalFibOmega n (Omega B) (fibOmega B P f) fOm
       in (itMapOmega n (Sigma BOm.1 POm, (pt BOm, fOm))
            (Omega (Sigma B.1 P, (pt B, f)))
            (totalFibOmega B P f,<_ _> (pt B, f))).1 (ih x)



-- B.8.3 Looping the Hopf fibration
one : nat = suc zero
two : nat = suc one
three : nat = suc two

HopfOne : (Omega S2pt).1 -> U = itFibOmega one S2pt Hopf base

HopfTwo : (Omega2 S2pt).1 -> U = itFibOmega two S2pt Hopf base

HopfThree : (Omega3 S2pt).1 -> U = itFibOmega three S2pt Hopf base

inhOrTrunc (A : U) : nat -> U = split
  zero  -> A
  suc n -> (x y : A) -> inhOrTrunc (Path A x y) n

-- TODO: change to transGen
subst' (A : U) (P : A -> U) (a b : A) (p : Path A a b) (e : P a) : P b =
  transport (<i> P (p @ i)) e

funDepTr (A : U) (P : A -> U) (a0 a1 : A) (p : Path A a0 a1) (u0 : P a0) (u1 : P a1) :
         Path U (PathP (<i> P (p @ i)) u0 u1)
                (Path (P a1) (subst' A P a0 a1 p u0) u1) =
  <j> PathP (<i> P (p @ j \/ i)) (comp (<i> P (p @ j /\ i)) u0 [ (j=0) -> <_> u0 ]) u1

truncFibOmega (B : ptType) (P : B.1 -> U) (f : P (pt B)) (n : nat)
  (tr : inhOrTrunc (P (pt B)) (suc n)) (p : (Omega B).1) : inhOrTrunc (fibOmega B P f p) n =
  let trf : inhOrTrunc (Path (P B.2) (subst' B.1 P (pt B) (pt B) p f) f) n =
        tr (subst' B.1 P (pt B) (pt B) p f) f
      eq : Path U (Path (P (pt B)) (subst' B.1 P (pt B) (pt B) p f) f)
                  (PathP (<i> P (p @ i)) f f) =
                    <i> funDepTr B.1 P (pt B) (pt B) p f f @ -i
  in subst U (\(X : U) -> inhOrTrunc X n)
             (Path (P (pt B)) (subst' B.1 P (pt B) (pt B) p f) f)
             (PathP (<i> P (p @ i)) f f)
             eq trf


-------
-- We now need that S1 is a groupoid

-- I now do this by proving that loopS1 is a retract of Z, as Z is a
-- set this is also set. Previously the proof transported the proof
-- that Z is a set to loopS1 along the equivalence loopS1 ~= Z,
-- hopefully this proof will compute faster.

-- Q: Is this crucial for the computation?



retract (A B : U) (f : A -> B) (g : B -> A) : U =
  (a : A) -> Path A (g (f a)) a

compUp (A : U) (a a' b b' : A) (p : Path A a a') (q : Path A b b')
  (r : Path A a b) : Path A a' b' =
    <i> hcomp A (r @ i) [(i = 0) -> p, (i = 1) -> q]

lemRetract (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
  (x y : A) : Path A (g (f x)) (g (f y)) -> Path A x y =
    compUp A (g (f x)) x (g (f y)) y (rfg x) (rfg y)

retractProp (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
  (pB : prop B) (x y : A) : Path A x y =
    lemRetract A B f g rfg x y (<i> g (pB (f x) (f y) @ i))

retractInv (A B : U)  (f : A -> B) (g : B -> A) (rfg : retract A B f g)
  (x y : A) (q : Path B (f x) (f y)) : Path A x y =
    <i> hcomp A (g (q @ i)) [(i = 0) -> rfg x, (i = 1) -> rfg y]

lemRSquare (A B : U) (f : A -> B) (g : B -> A)
           (rfg : (a : A) -> Path A (g (f a)) a)
           (x y : A) (p : Path A x y) :
  Square A (g (f x)) (g (f y)) x y
           (<i> g (f (p @ i)))
           (<i> hcomp A (g (f (p @ i))) [(i = 0) -> rfg x, (i = 1) -> rfg y])
           (rfg x)
           (rfg y) =
           <i j> hcomp A (g (f (p @ i))) [ (i = 0) -> <k> rfg x @ j /\ k
                                         , (i = 1) -> <k> rfg y @ j /\ k
                                         , (j = 0) -> <k> g (f (p @ i)) ]

retractPath (A B : U)(f : A -> B) (g : B -> A) (rfg : retract A B f g) (x y :A) (p:Path A x y) :
  Path (Path A x y) (retractInv A B f g rfg x y (<i> f (p@ i))) p =
    <i j> hcomp A (g (f (p @ j)))
                  [ (j=0) -> rfg x
                  , (j=1) -> rfg y
                  , (i=0) -> lemRSquare A B f g rfg x y p @ j
                  , (i=1) -> rfg (p @ j) ]


retractSet (A B : U) (f : A -> B) (g : B -> A) (rfg : retract A B f g)
           (sB : set B) (x y : A) : prop (Path A x y) =
  retractProp (Path A x y) (Path B (f x) (f y)) (\(p : Path A x y) -> <i> f (p @ i))
              (retractInv A B f g rfg x y) (retractPath A B f g rfg x y) (sB (f x) (f y))

-- This not needed!
-- loopS1equalsZ : Path U loopS1 Z =
--   isoPath loopS1 Z (encode base) (decode base) decodeEncodeBase (encodeDecode base)

-- Z is a set
data N0 =

efq (A : U) : N0 -> A = split {}
not (A : U) : U = A -> N0

data or (A B : U) = inl (a : A)
                  | inr (b : B)

data Unit = tt

stable (A : U) : U = not (not A) -> A
const (A : U) (f : A -> A) : U = (x y : A) -> Path A (f x) (f y)

exConst (A : U) : U = (f:A -> A) * const A f
propN0 : prop N0 = \ (x y:N0) -> efq (Path N0 x y) x

propNot (A : U) : prop (not A) = \ (f g:not A) -> <i>\(x:A) -> (propN0 (f x) (g x))@i

dNot (A : U) (a : A) : not (not A) = \ (h : not A) -> h a

stableConst (A : U) (sA : stable A) : exConst A =
 (\ (x:A) -> sA (dNot A x),\ (x y:A) -> <i>sA (propNot (not A) (dNot A x) (dNot A y) @ i))

dec (A : U) : U = or A (not A)

decEqCong (A B : U) (f : A -> B) (g : B -> A) : dec A -> dec B = split
  inl a -> inl (f a)
  inr h -> inr (\ (b:B) -> h (g b))

decStable (A : U) : dec A -> stable A = split
 inl a -> \ (h :not (not A)) -> a
 inr b -> \ (h :not (not A)) -> efq A (h b)

discrete (A : U) : U = (a b : A) -> dec (Path A a b)

hedbergLemma (A: U) (a b:A) (f : (x : A) -> Path A a x -> Path A a x) (p : Path A a b) :
            Square A a a a b (<_> a) p (f a (<_> a)) (f b p) =
 comp (<i> Square A a a a (p @ i) (<_> a) (<j> p @ i /\ j)
                 (f a (<_> a)) (f (p @ i) (<j> p @ i /\ j)))
      (<i> f a (<_> a)) []

hedbergStable (A : U) (a b : A) (h : (x : A) -> stable (Path A a x))
        (p q : Path A a b) : Path (Path A a b) p q =
 <j i> comp (<_> A) a [ (j = 0) -> rem2 @ i
                      , (j = 1) -> rem3 @ i
                      , (i = 0) -> r
                      , (i = 1) -> rem4 @ j]
 where
   rem1 (x : A) : exConst (Path A a x) = stableConst (Path A a x) (h x)
   f (x : A) : Path A a x -> Path A a x  = (rem1 x).1
   fIsConst (x : A) : const (Path A a x) (f x) = (rem1 x).2
   rem4 : Square A a a b b (<_> a) (<_> b) (f b p) (f b q)  = fIsConst b p q
   r : Path A a a = f a (<_> a)
   rem2 : Square A a a a b (<_> a) p r (f b p) = hedbergLemma A a b f p
   rem3 : Square A a a a b (<_> a) q r (f b q) = hedbergLemma A a b f q

hedbergS (A : U) (h : (a x : A) -> stable (Path A a x)) : set A =
 \(a b : A) -> hedbergStable A a b (h a)

hedberg (A : U) (h : discrete A) : set A =
 \(a b : A) -> hedbergStable A a b (\(b : A) -> decStable (Path A a b) (h a b))

caseNat (A : U) (a0 aS : A) : nat -> A = split
 zero -> a0
 suc n -> aS

caseDNat (P:nat -> U) (a0 :P zero) (aS : (n:nat) -> P (suc n))
            : (n:nat) -> P n = split
 zero -> a0
 suc n -> aS n

znots (n : nat) : not (Path nat zero (suc n)) =
  \(h : Path nat zero (suc n)) -> subst nat (caseNat U nat N0) zero (suc n) h zero

snotz (n : nat) : not (Path nat (suc n) zero) =
  \(h : Path nat (suc n) zero) -> znots n (<i> h @ -i)

pred : nat -> nat = split
  zero -> zero
  suc n -> n

sucInj (n m : nat) (p : Path nat (suc n) (suc m)) : Path nat n m =
 <i> pred (p @ i)

discreteNat : discrete nat = split
 zero -> caseDNat (\(m : nat) -> dec (Path nat zero m)) (inl (<_> zero)) (\(m : nat) -> inr (znots m))
 suc n -> caseDNat (\(m : nat) -> dec (Path nat (suc n) m)) (inr (snotz n))
   (\(m : nat) -> decEqCong (Path nat n m) (Path nat (suc n) (suc m)) (\(p : Path nat n m) -> <i> suc (p @ i))
                  (sucInj n m) (discreteNat n m))

posNotneg (a b : nat) (h : Path Z (pos a) (neg b)) : N0 = subst Z T (pos a) (neg b) h tt
  where
  T : Z -> U = split
       pos _ -> Unit
       neg _ -> N0

negNotpos (a b : nat) (h : Path Z (neg b) (pos a)) : N0 = subst Z T (neg b) (pos a) h tt
  where
  T : Z -> U = split
       pos _ -> N0
       neg _ -> Unit

injPos (a b : nat) (h : Path Z (pos a) (pos b)) : Path nat a b =
 subst Z T (pos a) (pos b) h (<_> a)
 where
   T : Z -> U = split
        pos c -> Path nat a c
        neg _ -> N0

injNeg (a b : nat) (h : Path Z (neg a) (neg b)) : Path nat a b =
  subst Z T (neg a) (neg b) h (<_> a)
  where
    T : Z -> U = split
         pos _ -> N0
         neg c -> Path nat a c

discreteZ : discrete Z = split
  pos a -> split@((z1 : Z) -> dec (Path Z (pos a) z1)) with
             pos a1 -> let rem : dec (Path nat a a1) -> dec (Path Z (pos a) (pos a1)) = split
                             inl p -> inl (<i> pos (p @ i))
                             inr h -> inr (\(p : Path Z (pos a) (pos a1)) -> h (injPos a a1 p))
                       in rem (discreteNat a a1)
             neg b -> inr (posNotneg a b)
  neg b -> split@((z1 : Z) -> dec (Path Z (neg b) z1)) with
             pos a -> inr (negNotpos a b)
             neg b1 -> let rem : dec (Path nat b b1) -> dec (Path Z (neg b) (neg b1)) = split
                             inl p -> inl (<i> neg (p @ i))
                             inr h -> inr (\(p : Path Z (neg b) (neg b1)) -> h (injNeg b b1 p))
                       in rem (discreteNat b b1)


ZSet : set Z = hedberg Z discreteZ
--

-- No need for substituting in the universe here
-- setLoop : set loopS1 = subst U set Z loopS1 (<i> loopS1equalsZ @ -i) ZSet

predZ : Z -> Z = split
  pos u -> auxpredZ u
    where
    auxpredZ : nat -> Z = split
      zero  -> neg zero
      suc n -> pos n
  neg v -> neg (suc v)

sucZ : Z -> Z = split
  pos u -> pos (suc u)
  neg v -> auxsucZ v
    where
    auxsucZ : nat -> Z = split
      zero  -> pos zero
      suc n -> neg n

predsucZ : (x : Z) -> Path Z (predZ (sucZ x)) x = split
  pos u -> <_> pos u
  neg v -> lem v
   where
    lem : (u : nat) -> Path Z (predZ (sucZ (neg u))) (neg u) = split
      zero  -> <_> neg zero
      suc n -> <_> neg (suc n)

sucpredZ : (x : Z) -> Path Z (sucZ (predZ x)) x = split
  pos u -> lem u
   where
    lem : (u : nat) -> Path Z (sucZ (predZ (pos u))) (pos u) = split
      zero  -> <_> pos zero
      suc n -> <_> pos (suc n)
  neg v -> <_> neg v

lemIso (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x)
       (y : B) (x0 x1 : A) (p0 : Path B y (f x0)) (p1 : Path B y (f x1)) :
       Path (fiber A B f y) (x0,p0) (x1,p1) = <i> (p @ i,sq1 @ i)
  where
    rem0 : Path A (g y) x0 =
      <i> hcomp A (g (p0 @ i)) [ (i = 1) -> t x0, (i = 0) -> <k> g y ]

    rem1 : Path A (g y) x1 =
      <i> hcomp A (g (p1 @ i)) [ (i = 1) -> t x1, (i = 0) -> <k> g y ]

    p : Path A x0 x1 =
     <i> hcomp A (g y) [ (i = 0) -> rem0
                            , (i = 1) -> rem1 ]

    fill0 : Square A (g y) (g (f x0)) (g y) x0
                     (<i> g (p0 @ i)) rem0 (<i> g y) (t x0)  =
      <i j> hcomp A (g (p0 @ i)) [ (i = 1) -> <k> t x0 @ j /\ k
                                      , (i = 0) -> <k> g y
                                      , (j = 0) -> <k> g (p0 @ i) ]

    fill1 : Square A (g y) (g (f x1)) (g y) x1
                     (<i> g (p1 @ i)) rem1 (<i> g y) (t x1) =
      <i j> hcomp A (g (p1 @ i)) [ (i = 1) -> <k> t x1 @ j /\ k
                                      , (i = 0) -> <k> g y
                                      , (j = 0) -> <k> g (p1 @ i) ]

    fill2 : Square A (g y) (g y) x0 x1
                     (<k> g y) p rem0 rem1 =
      <i j> hcomp A (g y) [ (i = 0) -> <k> rem0 @ j /\ k
                               , (i = 1) -> <k> rem1 @ j /\ k
                               , (j = 0) -> <k> g y ]

    sq : Square A (g y) (g y) (g (f x0)) (g (f x1))
                  (<i> g y) (<i> g (f (p @ i)))
                  (<j> g (p0 @ j)) (<j> g (p1 @ j)) =
      <i j> hcomp A (fill2 @ i @ j) [ (i = 0) -> <k> fill0 @ j @ -k
                                         , (i = 1) -> <k> fill1 @ j @ -k
                                         , (j = 0) -> <k> g y
                                         , (j = 1) -> <k> t (p @ i) @ -k ]

    sq1 : Square B y y (f x0) (f x1)
                   (<k>y) (<i> f (p @ i)) p0 p1 =
      <i j> hcomp B (f (sq @ i @j)) [ (i = 0) -> s (p0 @ j)
                                         , (i = 1) -> s (p1 @ j)
                                         , (j = 1) -> s (f (p @ i))
                                         , (j = 0) -> s y ]

gradLemma (A B : U) (f : A -> B) (g : B -> A)
       (s : (y : B) -> Path B (f (g y)) y)
       (t : (x : A) -> Path A (g (f x)) x) : isEquiv A B f =
  \(y:B) -> ((g y,<i>s y@-i),\ (z:fiber A B f y) ->
    lemIso A B f g s t y (g y) z.1 (<i>s y@-i) z.2)

isoPath (A B : U) (f : A -> B) (g : B -> A)
      (s : (y : B) -> Path B (f (g y)) y)
      (t : (x : A) -> Path A (g (f x)) x) : Path U A B =
       <i> Glue B [ (i = 0) -> (A,f,gradLemma A B f g s t)
                  , (i = 1) -> (B,idfun B,idIsEquiv B) ]

sucPathZ : Path U Z Z = isoPath Z Z sucZ predZ sucpredZ predsucZ

helix : S1 -> U = split
  base -> Z
  loop @ i -> sucPathZ @ i

encode (x : S1) (p : Path S1 base x) : helix x = subst S1 helix base x p zeroZ


lem1ItPos : (n:nat) -> Path loopS1 (loopIt (sucZ (pos n))) (oneTurn ((loopIt (pos n)))) = split
 zero -> refl loopS1 (oneTurn (<_> base))
 suc p -> <i>oneTurn (lem1ItPos p@i)


-- Clean
compInv (A:U) (a:A) : (x:A) (p:Path A a x) -> Path (Path A x x) (<_>x) (compPath A x a x (<i>p@-i) p) =
 J A a (\  (x:A) (p:Path A a x) -> Path (Path A x x) (<_>x) (compPath A x a x (<i>p@-i) p)) rem
 where rem : Path (Path A a a) (<_>a) (<i>hcomp A a [(i=0) -> <_>a,(i=1) -> <_>a]) =
        <j i>hcomp A a [(j=0) -> <_>a,(i=0) -> <_>a,(i=1) -> <_>a]

compInvS1 : Path loopS1 (refl S1 base) (compS1 invLoop loopP) = compInv S1 base base loopP

-- why this one with the same name? clean!
compInv (A:U) (a b:A) (q:Path A a b) : (x:A) (p:Path A b x) -> Path (Path A a b) q (compPath A a x b (compPath A a b x q p) (<i>p@-i)) =
 J A b (\ (x:A) (p:Path A b x) -> Path (Path A a b) q (compPath A a x b (compPath A a b x q p) (<i>p@-i))) rem
 where rem : Path (Path A a b) q
                           (<i>hcomp A (hcomp A (q@i) [(i=0) -> <_>a,(i=1) -> <_>b]) [(i=0) -> <_>a,(i=1) -> <_>b]) =
          <j i>hcomp A (hcomp A (q@i) [(j=0) -> <_>q@i,(i=0) -> <_>a,(i=1) -> <_>b]) [(j=0) -> <_>q@i,(i=0) -> <_>a,(i=1) -> <_>b]


lem1ItNeg : (n:nat) -> Path loopS1 (loopIt (sucZ (neg n))) (oneTurn (loopIt (neg n))) = split
 zero -> compInvS1
 suc p -> compInv S1 base base (loopIt (neg p)) base invLoop

lem1It : (n:Z) -> Path loopS1 (loopIt (sucZ n)) (oneTurn (loopIt n)) = split
  pos n -> lem1ItPos n
  neg n -> lem1ItNeg n

-- This should be used above!
transGen0 (A : U) (a : A) : A = transGen (<_> A) 0 a

lemTransGen0 (A : U) (a : A) : Path A (transGen0 A a) a =
  -- let rem1 : Path A a (hcomp A (transGen (<_> A) 0 a) []) = fill (<_> A) a []
  --     rem2 : Path A (transGen (<_> A) 0 a) (hcomp A (transGen (<_> A) 0 a) []) =
  --       hfill A (transGen (<_> A) 0 a) []
  -- in compPath A (transGen0 A a) (hcomp A (transGen (<_> A) 0 a) []) a rem2 (<i> rem1 @ -i)
  <i> hcomp A (hfill A (transGen (<_> A) 0 a) [] @ i)
           [ (i = 0) -> <_> transGen0 A a
           , (i = 1) -> <j> fill (<_> A) a [] @ -j ]

lemFib1 (A:U) (F G : A -> U) (a:A) (fa : F a -> G a) :
   (x:A) (p : Path A a x) -> (fx : F x -> G x) ->
     Path U (Path (F a -> G x) (\(u : F a) -> subst A G a x p (fa u))
                               (\(u : F a) -> fx (subst A F a x p u)))
            (PathP (<i> F (p @ i) -> G (p @ i)) fa fx) =
  J A a (\(x : A) (p : Path A a x) -> (fx : F x -> G x) ->
     Path U (Path (F a -> G x) (\(u : F a) -> subst A G a x p (fa u))
                               (\(u : F a) -> fx (subst A F a x p u)))
            (PathP (<i>F (p@i) -> G (p@i)) fa fx)) rem
  where
  rem (ga : F a -> G a) :
    Path U (Path (F a -> G a) (\(u : F a) -> transGen (<_> G a) 0 (fa u))
                              (\(u : F a) -> ga (transGen (<_> F a) 0 u)))
           (PathP (<_> F a -> G a) fa ga) =
      <j> Path (F a -> G a) (\(u : F a) -> lemTransGen0 (G a) (fa u) @ j)
                            (\(u : F a) -> ga (lemTransGen0 (F a) u @ j))

corFib1 (A:U) (F G : A -> U) (a:A) (fa ga : F a -> G a) (p:Path A a a)
  (h : (u:F a) -> Path (G a) (subst A G a a p (fa u)) (ga (subst A F a a p u))) :
  PathP (<i> F (p @ i) -> G (p @ i)) fa ga =
    comp (lemFib1 A F G a fa a p ga) (<i> \(u : F a) -> h u @ i) []

testHelix : Path (Z->Z) sucZ (subst S1 helix base base loopP) =
  let rem (x : Z) : Path Z (sucZ x) (hcomp Z (hcomp Z (transGen (<!0> Z) 0 (sucZ x)) []) []) =
        compPath Z (sucZ x)
                   (hcomp Z (transGen (<!0> Z) 0 (sucZ x)) [])
                   (hcomp Z (hcomp Z (transGen (<!0> Z) 0 (sucZ x)) []) [])
                   (fill (<_> Z) (sucZ x) [])
                   (hfill Z (hcomp Z (transGen (<!0> Z) 0 (sucZ x)) []) [])
  in   <i> \(x : Z) -> rem x @ i

keySquare : (x : S1) (q : Path S1 base x) ->
  Square S1 base base x x (lemTransGen0 S1 base) (<_> x) q q =
    J S1
      base
      (\(x : S1) (p : Path S1 base x) ->
         Square S1 base base x x (lemTransGen0 S1 base) (<_> x) p p)
      rem
    where
    -- This seems like a pain to prove:
    rem : Square S1 base base base base
             (lemTransGen0 S1 base) (<_> base) (<_> base) (<_> base) = undefined
  
decode : (x:S1) -> helix x -> Path S1 base x = split
  base -> loopIt
  loop @ i -> rem @ i
   where
   T : U = Z -> loopS1
   G (x:S1) : U =  Path S1 base x
   p : Path U T T = <j> helix (loopP @ j) -> Path S1 base (loopP@j)
   rem2 (x:Z) :
      Path loopS1 (oneTurn (loopIt x))
                  (loopIt (sucZ x)) = <i> lem1It x @ -i

   rem4 (x : Z) : Path (Path S1 base base)
        (<i> hcomp S1 (transGen0 S1 (loopIt x @ i))
                       [ (i = 0) -> <_> base
                       , (i = 1) -> loopP ])
        (<i> hcomp S1 (loopIt x @ i)
                       [ (i = 0) -> <_> base
                       , (i = 1) -> loopP ]) =
          let bottom : Square S1
                          (transGen0 S1 base) (transGen0 S1 base) base base
                          (<i> transGen0 S1 (loopIt x @ i))
                          (loopIt x)
                          (lemTransGen0 S1 base) (lemTransGen0 S1 base) =
                          <i j> lemTransGen0 S1 (loopIt x @ i) @ j
              -- front : Square S1
              --           (transGen0 S1 base) (transGen0 S1 base) base base
              --           (<i> transGen0 S1 (loopIt x @ i))
              --           (<i> hcomp S1 (transGen0 S1 (loopIt x @ i))
              --                   [ (i = 0) -> <_> base, (i = 1) -> loopP ])
              --           (<_> base) loopP =
              --               <i> hfill S1 (transGen0 S1 (loopIt x @ i))
              --                   [ (i = 0) -> <_> base, (i = 1) -> loopP ]
              -- back : Square S1 base base base base
              --          (loopIt x)
              --          (<i> hcomp S1 (loopIt x @ i)
              --                  [ (i = 0) -> <_> base, (i = 1) -> loopP ])
              --          (<_> base) loopP =
              --             <i> hfill S1 (loopIt x @ i)
              --                  [ (i = 0) -> <_> base, (i = 1) -> loopP ]
              -- left : Square S1 (transGen0 S1 base) base base base
              --           (lemTransGen0 S1 base)
              --           (<i> hcomp S1 (lemTransGen0 S1 base @ i)
              --                  [ (i = 0) -> <_> base, (i = 1) -> <_> base ])
              --           (<_> base) (<_> base) = 
              --             <i> hfill S1 (lemTransGen0 S1 base @ i)
              --                  [ (i = 0) -> <_> base, (i = 1) -> <_> base ]
              -- right : Square S1 (transGen0 S1 base) base base base
              --           (lemTransGen0 S1 base)
              --           (<i> hcomp S1 (lemTransGen0 S1 base @ i)
              --                  [ (i = 0) -> loopP, (i = 1) -> loopP ])
              --           loopP loopP  = 
              --             <i> hfill S1 (lemTransGen0 S1 base @ i)
              --                  [ (i = 0) -> loopP, (i = 1) -> loopP ]
              -- goal : Square S1 base base base base
              --         (<i> hcomp S1 (transGen0 S1 (loopIt x @ i)) [ (i = 0) -> <_> base, (i = 1) -> loopP ])
              --         (<i> hcomp S1 (loopIt x @ i) [ (i = 0) -> <_> base, (i = 1) -> loopP ])
              --         (<i> hcomp S1 (lemTransGen0 S1 base @ i) [ (i = 0) -> <_> base, (i = 1) -> <_> base ])
              --         (<i> hcomp S1 (lemTransGen0 S1 base @ i) [ (i = 0) -> loopP, (i = 1) -> loopP ])
              --         = <i j> hcomp S1 (bottom @ i @ j)
              --                   [ (i = 0) -> left @ j
              --                   , (i = 1) -> right @ j ]

              left' : Square S1 base base base base
                        (lemTransGen0 S1 base)
                        (<_> base)
                        (<_> base) (<_> base) = keySquare base (<_> base)
              right' : Square S1 base base base base
                        (lemTransGen0 S1 base)
                        (<_> base)
                        loopP loopP = keySquare base loopP
              goal' : Square S1 base base base base
                      (<i> hcomp S1 (transGen0 S1 (loopIt x @ i)) [ (i = 0) -> <_> base, (i = 1) -> loopP ])
                      (<i> hcomp S1 (loopIt x @ i) [ (i = 0) -> <_> base, (i = 1) -> loopP ])
                      (<_> base)
                      (<_> base)
                      = <i j> hcomp S1 (bottom @ i @ j)
                                [ (i = 0) -> left' @ j
                                , (i = 1) -> right' @ j ]
          in <i j> goal' @ j @ i


   rem3 (x : Z) :
     Path loopS1 (subst S1 G base base loopP (loopIt x))
                 (loopIt (sucZ x)) =
       compPath loopS1 (subst S1 G base base loopP (loopIt x))
         (oneTurn (loopIt x)) (loopIt (sucZ x))
         (rem4 x) (rem2 x)
   rem1 (x:Z) : Path loopS1 (subst S1 G base base loopP (loopIt x))
                           (loopIt (subst S1 helix base base loopP x)) =
    comp (<i> Path loopS1 (subst S1 G base base loopP (loopIt x))
                          (loopIt (testHelix @ i x))) (rem3 x) []
   rem : PathP p loopIt loopIt = corFib1 S1 helix G base loopIt loopIt loopP rem1

encodeDecode (x : S1) (p : Path S1 base x) : Path (Path S1 base x) (decode x (encode x p)) p =
  transport (<i> Path (Path S1 base (p @ i))
            (decode (p @ i) (encode (p @ i) (<j> p @ i /\ j))) (<j> p @ i /\ j))
            (<_> triv)

setLoop : set loopS1 = retractSet loopS1 Z (encode base) (decode base) (encodeDecode base) ZSet


lemPropFib (P : S1 -> U) (pP : (x : S1) -> prop (P x)) (bP : P base) : (x : S1) -> P x = split
 base -> bP
 loop @ i -> lemPropF S1 P pP base base loopP bP bP @ i

isGroupoidS1 : groupoid S1 = lem
 where
  lem2 : (y : S1) -> set (Path S1 base y)
    = lemPropFib (\(y : S1) -> set (Path S1 base y)) (\(y : S1) -> setIsProp (Path S1 base y)) setLoop

  lem : (x y : S1) -> set (Path S1 x y)
   = lemPropFib (\(x : S1) -> (y : S1) -> set (Path S1 x y)) pP lem2
     where
       pP (x : S1) : prop ((y : S1) -> set (Path S1 x y)) =
        propPi S1 (\(y : S1) -> set (Path S1 x y)) (\(y : S1) -> setIsProp (Path S1 x y))

-- opaque isGroupoidS1
-----

fibContrHopfThree (p : (Omega3 S2pt).1) : HopfThree p =
  truncFibOmega (Omega2 S2pt) HopfTwo (<_ _> base) zero
    (truncFibOmega (Omega S2pt) HopfOne (<_> base) one
       (truncFibOmega S2pt Hopf base two isGroupoidS1 (<_> north))
       (<_> pt (Omega S2pt))) p

-- The map h from 9.3
h (p : (Omega3 S2pt).1) : (Omega3 (joinpt S1pt S1)).1 =
  mapOmegaRefl3 (Sigma S2 Hopf, (north,base)) (join S1 S1) t'
    (itTotalFibOmega three S2pt Hopf base (p, fibContrHopfThree p))


--------------------------------------------------------------------------------
-- B.9 Going back to pi2(S2)

-- B.9.1 Truncations

-- 2-Groupoid truncation
data g2Trunc (A : U) =
    g2inc (a : A)
  | g2squashC (a b : g2Trunc A)
              (p q : Path (g2Trunc A) a b)
              (r s : Path (Path (g2Trunc A) a b) p q)
              (t u : Path (Path (Path (g2Trunc A) a b) p q) r s)
              <i j k l>
               [ (i=0) -> t @ j @ k @ l
               , (i=1) -> u @ j @ k @ l
               , (j=0) -> r @ k @ l
               , (j=1) -> s @ k @ l
               , (k=0) -> p @ l
               , (k=1) -> q @ l
               , (l=0) -> a
               , (l=1) -> b]

g2Truncpt (A : ptType) : ptType = (g2Trunc A.1,g2inc (pt A))


-- Groupoid truncation
data gTrunc (A : U) =
    ginc (a : A)
  | gsquashC (a b : gTrunc A) (p q : Path (gTrunc A) a b)
             (r s : Path (Path (gTrunc A) a b) p q) <i j k>
               [ (i=0) -> r @ j @ k
               , (i=1) -> s @ j @ k
               , (j=0) -> p @ k
               , (j=1) -> q @ k
               , (k=0) -> a
               , (k=1) -> b]

gTruncpt (A : ptType) : ptType = (gTrunc A.1,ginc (pt A))

-- Set truncation
data sTrunc (A : U) =
    sinc (a : A)
  | ssquashC (a b : sTrunc A) (p q : Path (sTrunc A) a b) <i j>
      [ (i=0) -> p @ j
      , (i=1) -> q @ j
      , (j=0) -> a
      , (j=1) -> b ]

sTruncpt (A : ptType) : ptType = (sTrunc A.1,sinc (pt A))

sTruncRec (A B : U) (bS : set B) (f : A -> B) : sTrunc A -> B = split
  sinc a -> f a
  ssquashC a b p q @ i j -> (bS (sTruncRec A B bS f a)
                              (sTruncRec A B bS f b)
                               (<k> sTruncRec A B bS f (p @ k))
                               (<k> sTruncRec A B bS f (q @ k))) @ i @ j

-- Propositional truncation (not needed?)
-- data pTrunc (A : U) =
--     inc (a : A)
--   | inh (x y : pTrunc A) <i> [(i=0) -> x, (i=1) -> y]

-- pTruncpt (A : ptType) : ptType = (pTrunc A.1,inc (pt A))

-- pTruncRec (A B : U) (pP : prop B) (f : A -> B) : pTrunc A -> B = split
--   inc a -> f a
--   inh x y @ i -> pP (pTruncRec A B pP f x) (pTruncRec A B pP f y) @ i


-- B.9.2 Truncated higher Hopf fibration

-- See https://github.com/simhu/cubical/blob/connections/examples/truncHopf.cub


--------------------------------------------------------------------------------
-- B.10 Loop space of truncations

-- See https://github.com/simhu/cubical/blob/connections/examples/loopTrunc.cub


--------------------------------------------------------------------------------
-- B.11 Down one more dimension

-- e'_2 from 12
pi2S2' (p : (Omega2 S2pt).1) : loopS1 =
  let point : (Omega S2pt).1 = pt (Omega S2pt)
  in subst (Omega S2pt).1 HopfOne point point p (<_> base)

e2' : sTrunc (Omega2 S2pt).1 -> loopS1 =
  sTruncRec (Omega2 S2pt).1 loopS1 setLoop pi2S2'


--------------------------------------------------------------------------------
-- B.2 The definition

f0 : Z -> loopS1 = loopIt

f1 : loopS1 -> (Omega2 S2pt).1 = (mapOmega S1pt (Omega S2pt) (phi S1pt)).1

f2 : (Omega2 S2pt).1 -> (Omega3 S3pt).1 = (mapOmega2 S2pt (Omega S3pt) (phi S2pt)).1

f3 : (Omega3 S3pt).1 -> (Omega3 (joinpt S1pt S1)).1 = mapOmegaRefl3 S3pt (join S1 S1) e

-- Decompose f3 and test the 3 first submaps separately:
f31 : (Omega3 S3pt).1 -> (Omega3 (joinpt boolpt S2)).1 =
  mapOmegaRefl3 S3pt (join bool S2) (psi S2)

f32 : (Omega3 S3pt).1 -> (Omega3 (joinpt boolpt (join bool S1))).1 =
  mapOmegaRefl3 S3pt (join bool (join bool S1))
  (\(x : S3) -> mapJoin bool bool S2 (join bool S1) (idfun bool) (psi S1)
               (psi S2 x))

f33 : (Omega3 S3pt).1 -> (Omega3 (joinpt (joinpt boolpt bool) S1)).1 =
  mapOmegaRefl3 S3pt (join (join bool bool) S1)
  (\(x : S3) -> joinassoc1 bool bool S1
               (mapJoin bool bool S2 (join bool S1) (idfun bool) (psi S1)
               (psi S2 x)))

f4 : (Omega3 (joinpt S1pt S1)).1 -> (Omega3 S2pt).1 =
  -- (mapOmega3 (joinpt S1pt S1) S2pt alpha).1
  mapOmegaRefl3 (joinpt S1pt S1) S2 alpha.1

f5 : (Omega3 S2pt).1 -> (Omega3 (joinpt S1pt S1)).1 = h

f6 : (Omega3 (joinpt S1pt S1)).1 -> (Omega3 S3pt).1 =
  mapOmegaRefl3 (joinpt S1pt S1) S3 einv

f7 : (Omega3 S3pt).1 -> (Omega2 (g2Truncpt S2pt)).1 = undefined

f8 : (Omega2 (g2Truncpt S2pt)).1 -> (Omega (gTruncpt (Omega S2pt))).1 = undefined

f9 : (Omega (gTruncpt (Omega S2pt))).1 -> sTrunc (Omega2 S2pt).1 = undefined

f10 : sTrunc (Omega2 S2pt).1 -> loopS1 = e2'

-- I think this is correct
f11 (p : loopS1) : Z = encode base p

-- WORKS
test0To1 : (Omega2 S2pt).1 = f1 (f0 oneZ)

-- WORKS
test0To2 : (Omega3 S3pt).1 = f2 test0To1

-- WORKS
test0To31 : (Omega3 (joinpt boolpt S2)).1 = f31 test0To2

-- WORKS: but HUGE
-- WORKS (without endpoint correction)
test0To32 : (Omega3 (joinpt boolpt (join bool S1))).1 = f32 test0To2

-- ? (out of memory)
-- WORKS (without endpoint correction)
test0To33 : (Omega3 (joinpt (joinpt boolpt bool) S1)).1 = f33 test0To2

-- ? (out of memory)
-- WORKS without endpoint correction (~1s)
test0To3 : (Omega3 (joinpt S1pt S1)).1 = f3 test0To2

-- ? (out of memory)
-- WORKS without endpoint correction (~2s)
test0To4 : (Omega3 S2pt).1 = f4 test0To3

-- ? (not finished)
test0To5 : (Omega3 (joinpt S1pt S1)).1 = f5 test0To4

-- ? (not finished)
test0To6 : (Omega3 S3pt).1 = f6 test0To5

-- ? (not finished)
test0To7 : (Omega2 (g2Truncpt S2pt)).1 = f7 test0To6

-- ? (not finished)
test0To8 : (Omega (gTruncpt (Omega S2pt))).1 = f8 test0To7

-- ? (not finished)
test0To9 : sTrunc (Omega2 S2pt).1 = f9 test0To8

-- ? (not finished)
test0To10 : loopS1 = f10 test0To9

-- This should be "pos (suc (suc zero))"...
brunerie : Z = f11 test0To10
